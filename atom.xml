<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Running | 在路上</title>
  
  <subtitle>Still waters run deep.</subtitle>
  <link href="https://yzhblog.work/atom.xml" rel="self"/>
  
  <link href="https://yzhblog.work/"/>
  <updated>2020-11-25T17:20:37.952Z</updated>
  <id>https://yzhblog.work/</id>
  
  <author>
    <name>A minor</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【数据结构】LRU，从O(n)复杂度到O(1)</title>
    <link href="https://yzhblog.work/posts/255a4d73.html"/>
    <id>https://yzhblog.work/posts/255a4d73.html</id>
    <published>2020-10-31T16:00:00.000Z</published>
    <updated>2020-11-25T17:20:37.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在文章开头我们先放两个链接，因为在实现LRU时会直接复用Java提供的容器：</p><ul><li><a href="https://blog.csdn.net/weixin_43935927/article/details/108501190" target="_blank" rel="noopener">【Java容器源码】LinkedList源码分析</a>…</li><li><a href="https://blog.csdn.net/weixin_43935927/article/details/108512608" target="_blank" rel="noopener">【Java容器源码】LinkedHashMap源码分析</a>…</li></ul></blockquote><h2 id="1-单链表实现LRU（O-n-）"><a href="#1-单链表实现LRU（O-n-）" class="headerlink" title="1.单链表实现LRU（O(n)）"></a>1.单链表实现LRU（O(n)）</h2><p>单向链表，从head出，tail进入（理解成队列，左进（tail）右出（head）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 查找:</span><br><span class="line">  1.查找：遍历得到这个数据对应的结点</span><br><span class="line">  2.移动：将其从原来的位置删除，然后再插入到链表的尾部</span><br><span class="line">* 添加：查找 + （移动/删除）</span><br><span class="line">  - 缓存中已存在：移动到队尾</span><br><span class="line">  - 缓存中不存在：</span><br><span class="line">    - 缓存未满，则将此结点直接插入到链表的尾部</span><br><span class="line">    - 缓存已满，则链表**头结点删除**，将新的数据结点插入链表的尾部</span><br><span class="line">* 删除:</span><br><span class="line">  1.查找：遍历找到要删除节点</span><br><span class="line">  2.删除：用前驱节点删除</span><br></pre></td></tr></table></figure></p><blockquote><p>这三个操作都要涉及“查找”操作。所以，如果单纯地采用链表的话，时间复杂度只能是 <strong>O(n)</strong>。</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接继承Java的LinkedList，就不用再自己实现链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedLRU</span> <span class="keyword">extends</span> <span class="title">LinkedList</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capcity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedLRU</span> <span class="params">(<span class="keyword">int</span> capcity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capcity = capcity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果队列中包含要添加元素</span></span><br><span class="line">    <span class="keyword">if</span> (contains(str)) &#123;</span><br><span class="line">    <span class="comment">// 删除，然后再插入到队尾</span></span><br><span class="line">            remove(str);</span><br><span class="line">        <span class="comment">// 如果队列中不包含要添加元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列已经满乐，就将元素队首删除</span></span><br><span class="line">            <span class="keyword">if</span> (size() == capcity) &#123;</span><br><span class="line">                removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尾插</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查出结果</span></span><br><span class="line">        String item = <span class="keyword">super</span>.get(index);</span><br><span class="line">        <span class="comment">// 将当前元素删除</span></span><br><span class="line">        remove(index);</span><br><span class="line">        <span class="comment">// 然后再插入到尾部</span></span><br><span class="line">        add(item);</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLRU</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置容量大小为3，并加入3个元素</span></span><br><span class="line">        LinkedLRU lru = <span class="keyword">new</span> LinkedLRU(<span class="number">3</span>);</span><br><span class="line">        lru.add(<span class="string">"a"</span>);</span><br><span class="line">        lru.add(<span class="string">"b"</span>);</span><br><span class="line">        lru.add(<span class="string">"c"</span>);</span><br><span class="line">        System.out.println(<span class="string">"还未做任何操作："</span> + lru);</span><br><span class="line"><span class="comment">// 访问其中一个元素</span></span><br><span class="line"><span class="comment">// 按照lru的逻辑，被访问的元素要被挪动到队尾</span></span><br><span class="line">        lru.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"访问已存在元素(a)："</span> + lru);</span><br><span class="line">        <span class="comment">// 添加一个缓存中已经有了的元素</span></span><br><span class="line">        <span class="comment">// 按照lru的逻辑，该元素会被挪到队尾</span></span><br><span class="line">        lru.add(<span class="string">"b"</span>);</span><br><span class="line">        System.out.println(<span class="string">"添加一个已存在的元素(b)："</span> + lru);</span><br><span class="line"><span class="comment">// 添加一个缓存没有的元素，但此时队列已经满了</span></span><br><span class="line"><span class="comment">// 按照lru的逻辑，队首的元素会被删除</span></span><br><span class="line">        lru.add(<span class="string">"d"</span>);</span><br><span class="line">        System.out.println(<span class="string">"超过容量添加一个元素："</span> + lru);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><img src="https://img-blog.csdnimg.cn/20201122214503923.png#pic_center" alt="在这里插入图片描述"></p><h2 id="2-散列表-双向链表（O-1-）"><a href="#2-散列表-双向链表（O-1-）" class="headerlink" title="2.散列表 + 双向链表（O(1)）"></a>2.散列表 + 双向链表（O(1)）</h2><p>既然单纯使用链表实现LRU的时间复杂时O(n），那有什么办法优化吗？可以的，因为主要时间都浪费在查找上了，所以我们可以在链表的基础上再加上哈希表，因为哈希表的查询时间复杂度是O(1)，可以极大程度上优化查询时间。</p><p>结构图如下：<br><img src="https://img-blog.csdnimg.cn/20201122212349377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 查找：</span><br><span class="line">  1.查找：散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。</span><br><span class="line">  2.移动：当找到数据之后，我们还需要将它移动到双向链表的尾部。</span><br><span class="line">* 添加：找 + （移动/删除）</span><br><span class="line">  - 缓存中存在：将此节点移动到双向链表的尾部；</span><br><span class="line">  - 缓存中不存在：</span><br><span class="line">    - 缓存已满：将双向链表头部的结点删除，然后再将数据放到链表的尾部；</span><br><span class="line">    - 缓存未满：直接将数据新添到链表的尾部。</span><br><span class="line">* 删除：</span><br><span class="line">  1.查找：借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。</span><br><span class="line">  2.删除：因为我们的链表是双向链表， 双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点 只需要 O(1) 的时间复杂度。</span><br></pre></td></tr></table></figure></p><blockquote><p>这整个过程涉及的查找操作都可以通过散列表来完成。所以其他的操作，比如删除头结点、链表尾部插入数据等，都可以在 O(1) 的时间复杂度内完成。所以，这三个操作的时间复杂度都 是 <strong>O(1)</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过LinkedListMap来实现（Map + List）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75F</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if ((v = get(k)) == null)  return -1;</span></span><br><span class="line"><span class="comment">        else return v;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 没找到就返回默认</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// put方法实际上是调用HashMap的，但是LinkedHashMap重写了afterNodeAccess方法，所以无论要添加元素是否存在，都会被移到队尾</span></span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写removeEldestEntry来定义什么时候进行删除操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，实现了一个高效的、支持 LRU 缓存淘汰算法的缓存系统原型。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在文章开头我们先放两个链接，因为在实现LRU时会直接复用Java提供的容器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43935927/article/details/108501190&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【Java容器源码】LinkedList源码分析&lt;/a&gt;…&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43935927/article/details/108512608&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【Java容器源码】LinkedHashMap源码分析&lt;/a&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-单链表实现LRU（O-n-）&quot;&gt;&lt;a href=&quot;#1-单链表实现LRU（O-n-）&quot; class=&quot;headerlink&quot; title=&quot;1.单链表实现LRU（O(n)）&quot;&gt;&lt;/a&gt;1.单链表实现LRU（O(n)）&lt;/h2&gt;&lt;p&gt;单向链表，从head出，tail进入（理解成队列，左进（tail）右出（head）。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* 查找:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1.查找：遍历得到这个数据对应的结点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2.移动：将其从原来的位置删除，然后再插入到链表的尾部&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 添加：查找 + （移动/删除）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - 缓存中已存在：移动到队尾&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  - 缓存中不存在：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - 缓存未满，则将此结点直接插入到链表的尾部&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - 缓存已满，则链表**头结点删除**，将新的数据结点插入链表的尾部&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 删除:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1.查找：遍历找到要删除节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2.删除：用前驱节点删除&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这三个操作都要涉及“查找”操作。所以，如果单纯地采用链表的话，时间复杂度只能是 &lt;strong&gt;O(n)&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://yzhblog.work/categories/数据结构/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="数据结构&amp;算法" scheme="https://yzhblog.work/tags/数据结构-算法/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】数组：二维数组填数问题，蛇形填数三变式及杨辉三角</title>
    <link href="https://yzhblog.work/posts/7570a0f2.html"/>
    <id>https://yzhblog.work/posts/7570a0f2.html</id>
    <published>2020-10-12T16:00:00.000Z</published>
    <updated>2020-11-25T17:07:56.078Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>填数问题的核心就是找规律，然后得到<strong>递推关系</strong>！</p></blockquote><h3 id="1-蛇形填数一"><a href="#1-蛇形填数一" class="headerlink" title="1.蛇形填数一"></a>1.蛇形填数一</h3><p>如下图，第20行第20个数是什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  2  4  7  11</span><br><span class="line">3  5  8  12</span><br><span class="line">6  9  13</span><br><span class="line">10 14</span><br><span class="line">15</span><br></pre></td></tr></table></figure></p><hr><p><strong>思路</strong>：如果想一行一行或者一列一列的填，那肯定就很难想。但是斜着看就很简单了。</p><p><img src="https://img-blog.csdnimg.cn/20201102155330963.png#pic_center" alt="在这里插入图片描述"><br>所以思路就出来了，一次填一个对角线。那问题又来了，由于不是每条对角线上都有<code>行=列</code>的点，所以第20行20列的数在哪个对角线上呢？从上面的图可以分析出，<code>行=列</code>的元素一定在第奇数条对角线，比如(1,1)=1在第一条，(2,2)=5在第三条。所以可以得到2n-1的关系，即(20,20)在第39条对角线。</p><a id="more"></a><p>方案一：以第一行元素（<code>arr[0][i]</code>）作为每条对角线填数的基准。</p><p><img src="https://img-blog.csdnimg.cn/20201102163754936.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">39</span>][<span class="number">40</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = i; x &lt;= i; x++,y--) <span class="comment">// 从arr[0][i]开始填</span></span><br><span class="line">                arr[x][y] = count++;</span><br><span class="line">                </span><br><span class="line">        System.out.println(arr[<span class="number">19</span>][<span class="number">19</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：以第一列元素（<code>arr[i][0]</code>）作为每条对角线填数的基准<br><img src="https://img-blog.csdnimg.cn/20201102163901403.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = i, y = <span class="number">0</span>; x &gt;= <span class="number">0</span>; x--, y++) <span class="comment">// 从arr[i][0]开始填</span></span><br><span class="line">                arr[x][y] = count++;</span><br><span class="line"></span><br><span class="line">        System.out.println(arr[<span class="number">19</span>][<span class="number">19</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20201102160554932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2-蛇形填数二"><a href="#2-蛇形填数二" class="headerlink" title="2.蛇形填数二"></a>2.蛇形填数二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  2  6  7  15</span><br><span class="line">3  5  8  14</span><br><span class="line">4  9  13</span><br><span class="line">10 12  </span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>填数规律如下：<br><img src="https://img-blog.csdnimg.cn/20201102161048134.png#pic_center" alt="在这里插入图片描述"><br>求第20行20列的数是什么？</p><hr><p><strong>思路</strong>：这个题与上题本质其实一样，如果想着逐行或逐列填数的话，问题就变复杂了。所以还是要挨个对角线填，只不过在填的时候，基准数需要随着变化 ==&gt; 上题的方案一方案二搭配使用</p><p><img src="https://img-blog.csdnimg.cn/20201102163601355.png#pic_center" alt="在这里插入图片描述"></p><p>奇数对角线以第一行（<code>arr[0][i]</code>）作为填数基准，偶数对角线以第一列（<code>arr[i][0]</code>）作为填数基准</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">39</span>][<span class="number">39</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">39</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果是第奇数条对角线，就以第一列（arr[i][0]）作为填数基准</span></span><br><span class="line">            <span class="keyword">if</span> ((i+<span class="number">1</span>)%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = i, y = <span class="number">0</span>; x &gt;= <span class="number">0</span>; x--, y++)</span><br><span class="line">                    arr[x][y] = count++;</span><br><span class="line">                <span class="comment">// 如果是第偶数条对角线，就以第一行（arr[0][i]）作为填数基准</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = i; x &lt;= i; x++,y--)</span><br><span class="line">                    arr[x][y] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(arr[<span class="number">19</span>][<span class="number">19</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：答案还是761<br><img src="https://img-blog.csdnimg.cn/20201102164821907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="3-蛇形填数三"><a href="#3-蛇形填数三" class="headerlink" title="3.蛇形填数三"></a>3.蛇形填数三</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 11 12 1</span><br><span class="line">9  16 13 2  </span><br><span class="line">8  15 14 3</span><br><span class="line">7  6  5  4</span><br></pre></td></tr></table></figure><p>填数规律如下：</p><p><img src="https://img-blog.csdnimg.cn/20201102165532306.png#pic_center" alt="在这里插入图片描述"><br>求：现在输入方阵的维数n，将结果方阵打印出来（上面是n=4的示例）</p><hr><p><strong>思路</strong>：还是先找规律，可以分成四个小循环：上-&gt;下，右-&gt;左，下-&gt;上，左-&gt;右。<br><img src="https://img-blog.csdnimg.cn/20201102171707638.png#pic_center" alt="在这里插入图片描述"><br>逐行或逐列很简单，但是小循环的结束条件是什么呢？</p><ol><li>到边界就不填了<ol><li>由上到下填时，填到最下面（x=n）一行就不填了 ==&gt; x+1 &lt; n</li><li>由右到左填时，填到最左边（y=0）一列就不填了 ==&gt; y-1 &gt;= 0</li></ol></li><li>第一轮循环（填最外层）还可以用0和n作为边界条件，那第二轮呢？所以还得有一个结束条件，是当前数组当前位置没有填过数 ==&gt; arr[x][y]==0</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = n - <span class="number">1</span>;      <span class="comment">// 从右上角开始填数</span></span><br><span class="line">        <span class="keyword">int</span> count = arr[x][y] = <span class="number">1</span>; <span class="comment">// 右上角第一个数填1（注：如果不提前初始化，就永远无法进入内圈，陷入死循环）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当填到n²时表示填完了</span></span><br><span class="line">        <span class="keyword">while</span> (count &lt; n * n) &#123; </span><br><span class="line">            <span class="keyword">while</span> (x + <span class="number">1</span> &lt; n &amp;&amp; arr[x+<span class="number">1</span>][y] == <span class="number">0</span>) arr[++x][y] = ++count;  <span class="comment">// 由上到下</span></span><br><span class="line">            <span class="keyword">while</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[x][y-<span class="number">1</span>] == <span class="number">0</span>) arr[x][--y] = ++count; <span class="comment">// 由右到左</span></span><br><span class="line">            <span class="keyword">while</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[x-<span class="number">1</span>][y] == <span class="number">0</span>) arr[--x][y] = ++count; <span class="comment">// 由下到上</span></span><br><span class="line">            <span class="keyword">while</span> (y + <span class="number">1</span> &lt; n &amp;&amp; arr[x][y+<span class="number">1</span>] == <span class="number">0</span>) arr[x][++y] = ++count;  <span class="comment">// 由左到右</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) System.out.println(Arrays.toString(arr[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-杨辉三角形"><a href="#4-杨辉三角形" class="headerlink" title="4.杨辉三角形"></a>4.杨辉三角形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">1 2 1</span><br><span class="line">1 3 3 1</span><br><span class="line">1 4 6 4 1 </span><br><span class="line">1 5 10 10 5 1</span><br></pre></td></tr></table></figure><p>填数规律如下：任何一行的第一列和最后一列都是1。从第三行开始，每一个数据是它上一行的前一列和它上一行的本列之和</p><hr><p><strong>思路</strong>：这题跟上面比，其实很简单，递推公式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[i][j] = j == 0 ? arr[i-1][j] : arr[i-1][j] + arr[i-1][j-1];</span><br></pre></td></tr></table></figure></p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) </span><br><span class="line">                arr[i][j] = j == <span class="number">0</span> ? arr[i-<span class="number">1</span>][j] : arr[i-<span class="number">1</span>][j] + arr[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) System.out.println(Arrays.toString(arr[i]));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;填数问题的核心就是找规律，然后得到&lt;strong&gt;递推关系&lt;/strong&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-蛇形填数一&quot;&gt;&lt;a href=&quot;#1-蛇形填数一&quot; class=&quot;headerlink&quot; title=&quot;1.蛇形填数一&quot;&gt;&lt;/a&gt;1.蛇形填数一&lt;/h3&gt;&lt;p&gt;如下图，第20行第20个数是什么？&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1  2  4  7  11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3  5  8  12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6  9  13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10 14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：如果想一行一行或者一列一列的填，那肯定就很难想。但是斜着看就很简单了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201102155330963.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;所以思路就出来了，一次填一个对角线。那问题又来了，由于不是每条对角线上都有&lt;code&gt;行=列&lt;/code&gt;的点，所以第20行20列的数在哪个对角线上呢？从上面的图可以分析出，&lt;code&gt;行=列&lt;/code&gt;的元素一定在第奇数条对角线，比如(1,1)=1在第一条，(2,2)=5在第三条。所以可以得到2n-1的关系，即(20,20)在第39条对角线。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://yzhblog.work/categories/数据结构/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="数据结构&amp;算法" scheme="https://yzhblog.work/tags/数据结构-算法/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】缓存穿透，缓存击穿，缓存雪崩及解决方案</title>
    <link href="https://yzhblog.work/posts/4f0ffb79.html"/>
    <id>https://yzhblog.work/posts/4f0ffb79.html</id>
    <published>2020-10-06T16:00:00.000Z</published>
    <updated>2020-11-25T15:18:32.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h2><p>缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 通常出于容错的考虑， 如果从存储层查不到数据则不写入缓存层。 </p><p>缓存穿透将导致不存在的数据每次请求都要到存储层去查询， 失去了缓存保护后端存储的意义。 造成缓存穿透的基本原因有两个： </p><ol><li>自身业务代码或者数据出现问题。</li><li>一些恶意攻击、 爬虫等造成大量空命中。  </li></ol><p>缓存穿透问题解决方案： </p><a id="more"></a><p>方案一：缓存空对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 从缓存中获取数据 </span></span><br><span class="line">    String cacheValue = cache.get(key); </span><br><span class="line">    <span class="comment">// 缓存为空 </span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123; </span><br><span class="line">        <span class="comment">// 从存储中获取 </span></span><br><span class="line">        String storageValue = storage.get(key); </span><br><span class="line">        cache.set(key, storageValue); </span><br><span class="line">        <span class="comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123; </span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>); <span class="number">1</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> storageValue; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 缓存非空 </span></span><br><span class="line">        <span class="keyword">return</span> cacheValue; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：布隆过滤器 </p><p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。</p><p><img src="https://img-blog.csdnimg.cn/20201108172755861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>布隆过滤器就是一个大型的位数组和几个不一样的无偏 hash 函数。所谓无偏就是能够把元素的 hash 值算得比较均匀。 </p><p>向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就 完成了 add 操作。 </p><p>向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位 置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个key 不存在。</p><p>如果都是 1，这并不能说明这个  key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。</p><p>这种方法适用于数据命中不高、 数据相对固定、 实时性低（通常是数据集较大） 的应用场景， 代码维护较为复杂， 但是缓存空间占用很少。 </p><p> 可以用guava包自带的布隆过滤器，引入依赖： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>22.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例伪代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化布隆过滤器</span></span><br><span class="line"><span class="comment">// 1000：期望存入的数据个数，0.001：期望的误差率 </span></span><br><span class="line">BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charset.forName(<span class="string">"utf‐8"</span>)), <span class="number">1000</span>, <span class="number">0.001</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把所有数据存入布隆过滤器 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (String key: keys) &#123; </span><br><span class="line">        bloomFilter.put(key); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123; <span class="number">1</span></span><br><span class="line">    <span class="comment">// 从布隆过滤器这一级缓存判断下key是否存在 </span></span><br><span class="line">    Boolean exist = bloomFilter.mightContain(key); </span><br><span class="line">    <span class="keyword">if</span>(!exist)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 从缓存中获取数据 </span></span><br><span class="line">    String cacheValue = cache.get(key); </span><br><span class="line">    <span class="comment">// 缓存为空 </span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123; </span><br><span class="line">        <span class="comment">// 从存储中获取 </span></span><br><span class="line">        String storageValue = storage.get(key); </span><br><span class="line">        cache.set(key, storageValue); </span><br><span class="line">        <span class="comment">// 如果存储数据为空， 需要设置一个过期时间(300秒) </span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123; </span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> storageValue; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 缓存非空 </span></span><br><span class="line">        <span class="keyword">return</span> cacheValue;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多关于布隆过滤器的可以看这篇：<a href="https://blog.csdn.net/weixin_43935927/article/details/108935677" target="_blank" rel="noopener">【数据结构】布隆过滤器：BloomFilter原理及Java实现</a>…</p><h2 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2.缓存击穿"></a>2.缓存击穿</h2><p>开发人员使用“缓存+过期时间”的策略既可以加速数据读写， 又保证数据的定期更新， 这种模式基本能够满足绝大部分需求。 但是有两个问题如果同时出现， 可能就会对应用造成致命的危害： </p><ol><li>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。 </li><li>重建缓存不能在短时间完成， 可能是一个复杂计算， 例如复杂的SQL、 多次IO、 多个依赖等。 </li></ol><p>在缓存失效的瞬间， 有大量线程来重建缓存， 造成后端负载加大， 甚至可能会让应用崩溃。 要解决这个问题主要就是要避免大量线程同时重建缓存。 我们可以利用互斥锁来解决，此方法只允许一个线程重建缓存， 其他线程等待重建缓存的线程执行完， 重新从缓存获取数据即可。 </p><p>示例伪代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 从Redis中获取数据 </span></span><br><span class="line">    String value = redis.get(key); </span><br><span class="line">    <span class="comment">// 如果value为空， 则开始重构缓存 </span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">// 只允许一个线程重建缓存， 使用nx， 并设置过期时间ex </span></span><br><span class="line">        String mutexKey = <span class="string">"mutext:key:"</span> + key; </span><br><span class="line">        <span class="keyword">if</span> (redis.set(mutexKey, <span class="string">"1"</span>, <span class="string">"ex 180"</span>, <span class="string">"nx"</span>)) &#123; </span><br><span class="line">            <span class="comment">// 从数据源获取数据 </span></span><br><span class="line">            value = db.get(key); </span><br><span class="line">            <span class="comment">// 回写Redis， 并设置过期时间 1</span></span><br><span class="line">            redis.setex(key, timeout, value);</span><br><span class="line">            <span class="comment">// 删除key_mutex </span></span><br><span class="line">            redis.delete(mutexKey); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其他线程休息50毫秒后重试 </span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            Thread.sleep(<span class="number">50</span>); </span><br><span class="line">            get(key); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h2><p> 缓存雪崩是指，我们设置缓存时采用了相同的过期时间，所以大批量缓存在同一时间失效，导致流量会像奔逃的野牛一样， 打向后端存储层。 </p><p>由于缓存层承载着大量请求， 有效地保护了存储层， 但是如果缓存层由于某些原因不能提供服务(比如超大并发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问bigkey，导致缓存能支撑的并发急剧下降)， 于是大量请求都会达到存储层， 存储层的调用量会暴增， 造成存储层也会级联宕机的情况。  </p><blockquote><p>缓存雪崩是因为大面积的缓存失效，打崩了DB。而缓存击穿是值一个热点Key在不停的扛着大并发，当这个Key失效的瞬间，持续的大并发就穿破缓存，直接请求数据库。（也可以理解成缓存雪崩说的是很多key，而缓存击穿是某个热点key）</p></blockquote><p>对于这种情况我们在批量增加缓存时好将这一批数据的缓存过期时间设置为一个时间段内的不同时间。 </p><p>示例伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 从缓存中获取数据 </span></span><br><span class="line">    String cacheValue = cache.get(key); </span><br><span class="line">    <span class="comment">// 缓存为空 </span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123; </span><br><span class="line">        <span class="comment">// 从存储中获取 </span></span><br><span class="line">        String storageValue = storage.get(key); </span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">//设置一个过期时间(300到600之间的一个随机数) </span></span><br><span class="line">        <span class="keyword">int</span> expireTime = <span class="keyword">new</span> Random().nextInt(<span class="number">300</span>) + <span class="number">300</span>; </span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) &#123; </span><br><span class="line">            cache.expire(key, expireTime); <span class="number">13</span>  &#125; </span><br><span class="line">        <span class="keyword">return</span> storageValue; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 缓存非空 </span></span><br><span class="line">        <span class="keyword">return</span> cacheValue; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，预防和解决缓存雪崩问题， 还可以从以下三个方面进行着手：</p><ol><li>保证缓存层服务高可用性，比如使用Redis Sentinel或Redis Cluster。 </li><li>依赖隔离组件为后端限流并降级。比如使用Hystrix限流降级组件。 </li><li>提前演练。 在项目上线前， 演练缓存层宕掉后， 应用以及后端的负载情况以及可能出现的问题， 在此基础上做一些预案设定。</li></ol><p><img src="https://img-blog.csdnimg.cn/20201108180726363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-缓存穿透&quot;&gt;&lt;a href=&quot;#1-缓存穿透&quot; class=&quot;headerlink&quot; title=&quot;1.缓存穿透&quot;&gt;&lt;/a&gt;1.缓存穿透&lt;/h2&gt;&lt;p&gt;缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 通常出于容错的考虑， 如果从存储层查不到数据则不写入缓存层。 &lt;/p&gt;
&lt;p&gt;缓存穿透将导致不存在的数据每次请求都要到存储层去查询， 失去了缓存保护后端存储的意义。 造成缓存穿透的基本原因有两个： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自身业务代码或者数据出现问题。&lt;/li&gt;
&lt;li&gt;一些恶意攻击、 爬虫等造成大量空命中。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缓存穿透问题解决方案： &lt;/p&gt;</summary>
    
    
    
    <category term="数据存储" scheme="https://yzhblog.work/categories/数据存储/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】开发规范与性能优化建议</title>
    <link href="https://yzhblog.work/posts/d0a037fb.html"/>
    <id>https://yzhblog.work/posts/d0a037fb.html</id>
    <published>2020-09-22T16:00:00.000Z</published>
    <updated>2020-11-25T15:18:17.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-键值设计"><a href="#1-键值设计" class="headerlink" title="1.键值设计"></a>1.键值设计</h2><p><strong>1.key名设计</strong></p><blockquote><p>【建议】可读性和可管理性。</p></blockquote><p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trade:order:1</span><br></pre></td></tr></table></figure><blockquote><p>【建议】 简洁性。</p></blockquote><p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user:&#123;uid&#125;:friends:messages:&#123;mid&#125; 简化为 u:&#123;uid&#125;:fr:m:&#123;mid&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【强制】不要包含特殊字符。</p></blockquote><p>反例：包含空格、换行、单双引号以及其他转义字符</p><a id="more"></a><p><strong>2.value设计</strong></p><blockquote><p>【建议】选择适合的数据类型。 </p></blockquote><p>例如：实体类型(要合理控制和使用数据结构，但也要注意节省内存和性能之间的平衡) 。</p><p>反例： </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> user:<span class="number">1</span>:name tom</span><br><span class="line"><span class="built_in">set</span> user:<span class="number">1</span>:age <span class="number">19</span> </span><br><span class="line"><span class="built_in">set</span> user:<span class="number">1</span>:favor football</span><br></pre></td></tr></table></figure><p>正例: </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:<span class="number">1</span> name tom age <span class="number">19</span> favor football</span><br></pre></td></tr></table></figure><blockquote><p>【建议】控制key的生命周期，redis不是垃圾桶。</p></blockquote><p> 建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)。</p><blockquote><p>【强制】拒绝bigkey。(防止网卡流量、慢查询) </p></blockquote><p><strong>问题一</strong>：bigkey有什么危害？ </p><p>导致redis阻塞（过期删除)。有个bigkey，它安分守己（只执行简单的命令，例如hget、lpop、zscore等），但它设置了过期时间，当它过期后，会被删除，如果没有使用Redis 4.0的过期异步删除(lazyfree-lazyexpire yes)，就会存在阻塞Redis的可能性。  </p><p>网络拥塞。bigkey也就意味着每次获取要产生的网络流量较大，假设一个bigkey为1MB，客户端每秒访问量为1000，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB/s)的服务器来说简直是灭顶之灾，而且一般服务器会采用单机多实例的方式来部署，也就是说一个bigkey 可能会对其他实例也造成影响，其后果不堪设想。 </p><p><strong>问题二</strong>：Redis的bigkey具体指什么？</p><p>在Redis中，一个字符串大512MB，一个二级数据结构（例如hash、list、set、zset）可以存储大约40亿个(2^32-1)个元素，但实际中如果下面两种情况，一般就会认为它是bigkey：</p><ul><li>字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey</li><li>非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。</li></ul><p>一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。 反例：一个包含200万个元素的list。 </p><p><strong>问题三</strong>：什么情况下会产生bigkey？</p><p>大多数情况下，bigkey的产生都是由于程序设计不当，或者对于数据规模预料不清楚造成的，来看几个例子： </p><ol><li>社交类：粉丝列表，如果某些明星或者大v不精心设计下，必是bigkey。 </li><li>统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。 </li><li>缓存类：将数据从数据库load出来序列化放到Redis里，这个方式非常常用，但有两个地方需要注意：<ol><li>第一，是不是有必要把所有字段都缓存</li><li>第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个key下，产生bigkey</li></ol></li></ol><p><strong>问题四</strong>：如果出现了bigkey，那该如何优化？</p><p>第一个想法就是拆，看能不能将bigkey缩小：</p><ul><li>big list： list1、list2、…listN </li><li>big hash：可以将数据分段存储，比如一个大的key，假设存了1百万的用户数据，可以拆分成 200个key，每个key下面存放5000个用户数据 </li></ul><p>如果bigkey不可避免，也要思考一下要不要每次把所有元素都取出来(例如有时候仅仅需要 hmget，而不是hgetall)，删除也是一样，尽量使用优雅的方式来处理。比如，非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除。</p><p>最后，还要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞） </p><h2 id="2-命令使用（redis-cli）"><a href="#2-命令使用（redis-cli）" class="headerlink" title="2.命令使用（redis-cli）"></a>2.命令使用（redis-cli）</h2><blockquote><p>【推荐】O(N)命令关注N的数量。</p></blockquote><p>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有 遍历的需求可以使用hscan、sscan、zscan代替。</p><blockquote><p>【推荐】禁用命令。</p></blockquote><p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的 方式渐进式处理。</p><blockquote><p>【推荐】合理使用select。</p></blockquote><p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p><blockquote><p>【推荐】使用批量操作提高效率 。</p></blockquote><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原生命令：例如mget、mset。 </span><br><span class="line">非原生命令：可以使用pipeline提高效率。</span><br></pre></td></tr></table></figure><p>但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。 注意两者不同： </p><ol><li>原生是原子操作，pipeline是非原子操作。 </li><li>pipeline可以打包不同的命令，原生做不到 </li><li>pipeline需要客户端和服务端同时支持。</li></ol><blockquote><p>【推荐】Redis事务功能较弱，不建议过多使用，可以用lua替代。</p></blockquote><h2 id="3-客户端使用（Jedis）"><a href="#3-客户端使用（Jedis）" class="headerlink" title="3.客户端使用（Jedis）"></a>3.客户端使用（Jedis）</h2><blockquote><p>【推荐】 避免多个应用使用一个Redis实例。</p></blockquote><p>正例：不相干的业务拆分，公共数据做服务化。</p><blockquote><p>【推荐】 使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式： </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig(); </span><br><span class="line">jedisPoolConfig.setMaxTotal(<span class="number">5</span>); </span><br><span class="line">jedisPoolConfig.setMaxIdle(<span class="number">2</span>); </span><br><span class="line">jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, <span class="string">"192.168.0.60"</span>, <span class="number">6379</span>, <span class="number">3000</span>, <span class="keyword">null</span>);</span><br><span class="line">Jedis jedis = <span class="keyword">null</span>; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    jedis = jedisPool.getResource(); </span><br><span class="line"><span class="comment">// 具体的命令 </span></span><br><span class="line">    jedis.executeCommand() </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">    logger.error(<span class="string">"op key &#123;&#125; error: "</span> + e.getMessage(), key, e); </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="comment">// 注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。</span></span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) </span><br><span class="line">        jedis.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接池参数含义：</p><table><thead><tr><th>序号</th><th>参数名</th><th>含义</th><th>默认值</th><th>使用建议</th></tr></thead><tbody><tr><td>1</td><td>maxTotal</td><td>资源池中大连接数</td><td>8</td><td>设置建议见下面</td></tr><tr><td>2</td><td>maxIdle</td><td>资源池允许最大空闲的连接数</td><td>8</td><td>设置建议见下面</td></tr><tr><td>3</td><td>minIdle</td><td>资源池确保少空闲的连接数</td><td>0</td><td>设置建议见下面</td></tr><tr><td>4</td><td>blockWhenExhausted</td><td>当资源池用尽后，调用者是否要等待。<br>只有当为true时，下面的maxWaitMillis才会 生效</td><td>true</td><td>建议使用默认值</td></tr><tr><td>5</td><td>maxWaitMillis</td><td>当资源池连接用尽后，调用者的大等待时间(单位为毫秒)</td><td>-1：表示永不超时</td><td>不建议使用默认值</td></tr><tr><td>6</td><td>testOnBorrow</td><td>向资源池借用连接时 是否做连接有效性检测(ping)，无效连接会被移除</td><td>false</td><td>业务量很大时候建议设置为false(多一次ping的开销)。</td></tr><tr><td>7</td><td>testOnReturn</td><td>向资源池归还连接时是否做连接有效性检 测(ping)，无效连接会被移除</td><td>false</td><td>业务量很大时候建议设置为false(多一次 ping的开销)。</td></tr><tr><td>8</td><td>jmxEnabled</td><td>是否开启jmx监控，可用于监控</td><td>true</td><td>建议开启，但应用本身也要开启</td></tr></tbody></table><p>优化建议： </p><p>1）<strong>maxTotal</strong></p><p>最大连接数，早期的版本叫maxActive实际上这个是一个很难回答的问题，考虑的因素比较多：</p><ul><li>业务希望Redis并发量</li><li>客户端执行命令时间</li><li>Redis资源。例如 nodes(应用个数) * maxTotal 是不能超过redis的大连接数(maxclients)。 </li><li>资源开销。例如虽然希望控制空闲连接(连接池此刻可马上使用的连接)，但是不希望因为连接池的频繁释放创建连接造成不必靠开销。</li></ul><p>以一个例子说明，假设:</p><ul><li>一次命令时间（borrow|return resource + Jedis执行命令(含网络) ）的平均耗时约为 1ms，一个连接的QPS大约是1000 </li><li>业务期望的QPS是50000 </li></ul><p>那么理论上需要的资源池大小是50000 / 1000 = 50个。但事实上这是个理论值，还要考虑到要比理论值预留一些资源，通常来讲maxTotal可以比理论值大一些。 但这个值不是越大越好，一方面连接太多占用客户端和服务端资源，另一方面对于Redis这种高 QPS的服务器，一个大命令的阻塞即使设置再大资源池仍然会无济于事。 </p><p>2）<strong>maxIdle和minIdle</strong></p><p>maxIdle实际上才是业务需要的大连接数，maxTotal是为了给出余量，所以maxIdle不要设置过小，否则会有new Jedis(新连接)开销。 </p><p><strong>连接池的最佳性能是 maxTotal = maxIdle</strong>，这样就避免连接池伸缩带来的性能干扰。但是如果并发量不大或者maxTotal设置过高，会导致不必要的连接资源浪费。一般推荐maxIdle可以设置为按上面的业务期望QPS计算出来的理论连接数，maxTotal可以再放大一倍。 </p><p>minIdle（小空闲连接数），与其说是小空闲连接数，不如说是”至少需要保持的空闲连接数”，在使用连接的过程中，如果连接数超过了minIdle，那么继续建立连接，如果超过了 maxIdle，当超过的连接执行完业务后会慢慢被移出连接池释放掉。</p><p>如果系统启动完马上就会有很多的请求过来，那么可以给redis连接池做预热，比如快速的创建一些redis连接，执行简单命令，类似ping()，快速的将连接池里的空闲连接提升到minIdle的数量。 </p><p><strong>连接池预热</strong>示例代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Jedis&gt; minIdleJedisList = <span class="keyword">new</span> ArrayList&lt;Jedis&gt;(jedisPoolConfig.getMinIdle());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        jedis = pool.getResource(); </span><br><span class="line">        minIdleJedisList.add(jedis); </span><br><span class="line">        jedis.ping(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        logger.error(e.getMessage(), e); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 注意，这里不能马上close将连接还回连接池，否则最后连接池里只会建立1个连接。。 </span></span><br><span class="line">        <span class="comment">// jedis.close(); </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一将预热的连接还回连接池 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123; </span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">         jedis = minIdleJedisList.get(i); </span><br><span class="line">         <span class="comment">// 将连接归还回连接池 </span></span><br><span class="line">         jedis.close(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        logger.error(e.getMessage(), e); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，要根据实际系统的QPS和调用redis客户端的规模整体评估每个节点所使用的连接池大小。</p><blockquote><p>【推荐】 高并发下建议客户端添加熔断功能(例如netflix hystrix)</p></blockquote><blockquote><p>【推荐】 设置合理的密码，如有必要可以使用SSL加密访问</p></blockquote><blockquote><p>【推荐】 选择合适的删除策略。</p></blockquote><p>Redis对于过期键有三种清除策略： </p><ul><li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key </li><li><p>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key </p></li><li><p>当前已用内存超过maxmemory限定时，触发主动清理策略 </p></li></ul><p>注意，当Redis运行在主从模式时，只有主结点才会执行被动和主动这两种过期删除策略，然后把删除操作”del key”同步到从结点。</p><p>第三种策略的情况如下： 当前已用内存超过maxmemory限定时，会触发主动清理策略。所以，我们需要根据自身业务类型，选好maxmemory-policy(大内存淘汰策略)，设置好过期时间。如果不设置大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)， 会让 Redis 的性能急剧下降。 </p><p>默认策略是volatile-lru，即超过大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。 其他策略如下： </p><ul><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random: 随机删除过期键，直到腾出足够空间为止。 </li><li>volatile-ttl：根据键值对象的ttl属性，删除近将要过期数据。如果没有，回退到 noeviction策略。</li><li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error)  OOM command not allowed when used memory”，此时Redis只响应读操作。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-键值设计&quot;&gt;&lt;a href=&quot;#1-键值设计&quot; class=&quot;headerlink&quot; title=&quot;1.键值设计&quot;&gt;&lt;/a&gt;1.键值设计&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.key名设计&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;【建议】可读性和可管理性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id &lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;trade:order:1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;【建议】 简洁性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如： &lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;user:&amp;#123;uid&amp;#125;:friends:messages:&amp;#123;mid&amp;#125; 简化为 u:&amp;#123;uid&amp;#125;:fr:m:&amp;#123;mid&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;【强制】不要包含特殊字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反例：包含空格、换行、单双引号以及其他转义字符&lt;/p&gt;</summary>
    
    
    
    <category term="数据存储" scheme="https://yzhblog.work/categories/数据存储/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMQ】高级使用：四个问题详解事务消息</title>
    <link href="https://yzhblog.work/posts/73e8bd68.html"/>
    <id>https://yzhblog.work/posts/73e8bd68.html</id>
    <published>2020-08-22T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.956Z</updated>
    
    <content type="html"><![CDATA[<p>RocketMQ和其他消息中间件最大的一个区别是支持了事务消息，这也是分布式事务里面的基于消息的最终一致性方案。 </p><h3 id="1-事务消息是什么？"><a href="#1-事务消息是什么？" class="headerlink" title="1.事务消息是什么？"></a>1.事务消息是什么？</h3><p>事务消息：具有事务特性的消息，即Producer发送到broker后，该消息可以回滚或者提交（提交后Consumer才可见）。</p><h3 id="2-事务消息有什么用？"><a href="#2-事务消息有什么用？" class="headerlink" title="2.事务消息有什么用？"></a>2.事务消息有什么用？</h3><p>RocketMQ官方示例：用户A发起订单，支付100块钱操作完成后，能得到100积分，账户服务和会员服务是两个独立的微服务模块，有各自的数据库，按照上文提及的问题可能性，将会出现这些情况：</p><ul><li><p>如果先扣款，再发消息，可能钱刚扣完，宕机了，消息没发出去，结果积分没增加。</p></li><li><p>如果先发消息，再扣款，可能积分增加了，但钱没扣掉，白送了100积分给人家。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先扣款，再加积分伪代码：</span></span><br><span class="line"><span class="meta">@Transational</span></span><br><span class="line">pay() &#123;</span><br><span class="line">    mysql.payMoney() <span class="comment">// 数据库中添加用户信息</span></span><br><span class="line">    reduceRepo() <span class="comment">// 数据库中减少库存  </span></span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------<span class="comment">// 若先发消息再加积分，那在这行宕机怎么办？</span></span><br><span class="line">producer.send(msg) <span class="comment">// 发送100积分</span></span><br></pre></td></tr></table></figure><p>==&gt; 所以上述方式不可行，我们可以先发送消息（加积分）到Broker，但将消息置为Consumer不可见状态</p><ul><li>若本地事务（扣款）处理成功了再让Consumer可见</li><li>若本地事务（扣款）失败了就回滚当前消息</li></ul><blockquote><p>这里可能会存在一个问题，生产者本地事务成功后，发送事务确认消息到broker上失败了怎么办？<br>这个时候意味着消费者无法正常消费到这个消息。所以RocketMQ提供了<strong>消息回查机制</strong>，如果事务消息一直处于中间状态，broker会发起重试去查询broker上这个事务的处理状态。一旦发现事务处理成功，则把当前这条消息设置为可见</p></blockquote><p>整体的模型图如下：</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20201118192807424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>从上例我们看见，事务消息一般先于本地事务使用。这里也可以理解成嵌套事务，发消息是外层事务，本地事务是内存事务。</p></blockquote><h3 id="3-java使用事务消息？"><a href="#3-java使用事务消息？" class="headerlink" title="3.java使用事务消息？"></a>3.java使用事务消息？</h3><p>针对上面的示例，我们来看看如何通过具体的代码实现。</p><p>TransactionProducer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// 这里用的是事务Producer（TransactionMQProducer）</span></span><br><span class="line">        TransactionMQProducer transactionProducer=<span class="keyword">new</span> TransactionMQProducer(<span class="string">"tx_producer_group"</span>);</span><br><span class="line">        transactionProducer.setNamesrvAddr(<span class="string">"43.105.136.120:9876"</span>);    </span><br><span class="line">        <span class="comment">// 自定义线程池，用于异步执行事务操作     </span></span><br><span class="line">        transactionProducer.setExecutorService(Executors.newFixedThreadPool(<span class="number">10</span>); );  </span><br><span class="line">        <span class="comment">// 核心！！添加事务消息监听     </span></span><br><span class="line">        transactionProducer.setTransactionListener(<span class="keyword">new</span> TransactionListenerLocal());</span><br><span class="line">        transactionProducer.start();   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;       </span><br><span class="line">            String orderId= UUID.randomUUID().toString();    </span><br><span class="line">            String body=<span class="string">"&#123;'operation':'doOrder','orderId':'"</span>+orderId+<span class="string">"'&#125;"</span>;     </span><br><span class="line">            <span class="comment">// 构建消息</span></span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">"pay_tx_topic"</span>, <span class="string">"TagA"</span>,orderId, body.getBytes(RemotingHelper.DEFAULT_CHARSET));  </span><br><span class="line">            <span class="comment">// 发送消息， 注：是发送事务消息</span></span><br><span class="line">            transactionProducer.sendMessageInTransaction(message, orderId+<span class="string">"&amp;"</span>+i);   </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 1秒一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionListenerLocal（事务消息核心）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地事务监听，实现TransactionListener接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerLocal</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Boolean&gt; results=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行本地事务   </span></span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">":执行本地事务："</span>+arg.toString());    </span><br><span class="line">        String orderId=arg.toString();  </span><br><span class="line">        <span class="comment">// 模拟数据入库操作（成功/失败）</span></span><br><span class="line">        <span class="keyword">boolean</span> rs=saveOrder(orderId);</span><br><span class="line">        <span class="keyword">return</span> rs? LocalTransactionState.COMMIT_MESSAGE:LocalTransactionState.UNKNOW;  </span><br><span class="line">        <span class="comment">// 这个返回状态表示告诉broker这个事务消息是否被确认，允许给到consumer进行消费    </span></span><br><span class="line">        <span class="comment">// LocalTransactionState.ROLLBACK_MESSAGE 回滚    </span></span><br><span class="line">        <span class="comment">// LocalTransactionState.UNKNOW  未知   </span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提供事务执行状态的回查方法，提供给broker回调   </span></span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;  </span><br><span class="line">        String orderId=msg.getKeys();     </span><br><span class="line">        System.out.println(<span class="string">"执行事务执行状态的回查，orderId:"</span>+orderId);  </span><br><span class="line">        <span class="keyword">boolean</span> rs=Boolean.TRUE.equals(results.get(orderId));   </span><br><span class="line">        System.out.println(<span class="string">"回调："</span>+rs);     </span><br><span class="line">        <span class="keyword">return</span> rs?LocalTransactionState.COMMIT_MESSAGE:     </span><br><span class="line">        LocalTransactionState.ROLLBACK_MESSAGE;  </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">saveOrder</span><span class="params">(String orderId)</span></span>&#123;    </span><br><span class="line">        <span class="comment">//如果订单取模等于0，表示成功,否则表示失败  </span></span><br><span class="line">        <span class="keyword">boolean</span> success=Math.abs(Objects.hash(orderId))%<span class="number">2</span>==<span class="number">0</span>;   </span><br><span class="line">        results.put(orderId,success);    </span><br><span class="line">        <span class="keyword">return</span> success;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TransactionConsumer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, IOException </span>&#123;   </span><br><span class="line">        DefaultMQPushConsumer defaultMQPushConsumer=<span class="keyword">new</span>      </span><br><span class="line">            DefaultMQPushConsumer(<span class="string">"tx_consumer_group"</span>);   </span><br><span class="line">        defaultMQPushConsumer.setNamesrvAddr(<span class="string">"43.105.136.120:9876"</span>);       </span><br><span class="line">        defaultMQPushConsumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_O FFSET);   </span><br><span class="line">        defaultMQPushConsumer.subscribe(<span class="string">"pay_tx_topic"</span>,<span class="string">"*"</span>);    </span><br><span class="line">         </span><br><span class="line">        defaultMQPushConsumer.registerMessageListener((MessageListenerConcurrently)</span><br><span class="line">                  (msgs, context) -&gt; &#123;           </span><br><span class="line">                      msgs.stream().forEach(messageExt -&gt; &#123;    </span><br><span class="line">                          <span class="keyword">try</span> &#123;                 </span><br><span class="line">                              String orderId=messageExt.getKeys();</span><br><span class="line">                              <span class="comment">// 拿到消息</span></span><br><span class="line">                              String body=<span class="keyword">new</span> String(messageExt.getBody(), </span><br><span class="line">                                                     RemotingHelper.DEFAULT_CHARSET); </span><br><span class="line">                              <span class="comment">// 扣减库存</span></span><br><span class="line">                              System.out.println(<span class="string">"收到消息:"</span>+body+<span class="string">"，开始扣减库存："</span>+orderId);  </span><br><span class="line">                          &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;    </span><br><span class="line">                              e.printStackTrace();                </span><br><span class="line">                          &#125;             </span><br><span class="line">                      &#125;);   </span><br><span class="line">                      <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;    </span><br><span class="line">                  &#125;);     </span><br><span class="line">        defaultMQPushConsumer.start();    </span><br><span class="line">        System.in.read();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-事务消息的三种状态？"><a href="#4-事务消息的三种状态？" class="headerlink" title="4.事务消息的三种状态？"></a>4.事务消息的三种状态？</h3><p>在上面的 TransactionListenerLocal 类中，我们看见重写的两个方法都需要返回 LocalTransactionState，表示告诉broker对于这条已经存在了的事务消息如何处理：</p><ol><li><p>ROLLBACK_MESSAGE：回滚事务 </p><p>  当executeLocalTransaction方法返回ROLLBACK_MESSAGE时，表示直接回滚事务</p></li><li><p>COMMIT_MESSAGE： 提交事务 </p></li><li><p>UNKNOW： broker会定时的回查Producer消息状态，直到彻底成功或失败。</p><p>当返回UNKNOW时，Broker会在一段时间之后回查checkLocalTransaction，根据 checkLocalTransaction返回状态执行事务的操作（回滚或提交）</p></li></ol><p>如示例中，当返回 ROLLBACK_MESSAGE 时消费者不会收到消息，且不会调用回查函数，当返回 COMMIT_MESSAGE 时事务提交，消费者收到消息，当返回UNKNOW时，在一段时间之后调用回查函数，并根据status判断返回提交或回滚状态，返回提交状态的消息将会被消费者消费，所以此时消费者可以消费部分消息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RocketMQ和其他消息中间件最大的一个区别是支持了事务消息，这也是分布式事务里面的基于消息的最终一致性方案。 &lt;/p&gt;
&lt;h3 id=&quot;1-事务消息是什么？&quot;&gt;&lt;a href=&quot;#1-事务消息是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.事务消息是什么？&quot;&gt;&lt;/a&gt;1.事务消息是什么？&lt;/h3&gt;&lt;p&gt;事务消息：具有事务特性的消息，即Producer发送到broker后，该消息可以回滚或者提交（提交后Consumer才可见）。&lt;/p&gt;
&lt;h3 id=&quot;2-事务消息有什么用？&quot;&gt;&lt;a href=&quot;#2-事务消息有什么用？&quot; class=&quot;headerlink&quot; title=&quot;2.事务消息有什么用？&quot;&gt;&lt;/a&gt;2.事务消息有什么用？&lt;/h3&gt;&lt;p&gt;RocketMQ官方示例：用户A发起订单，支付100块钱操作完成后，能得到100积分，账户服务和会员服务是两个独立的微服务模块，有各自的数据库，按照上文提及的问题可能性，将会出现这些情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果先扣款，再发消息，可能钱刚扣完，宕机了，消息没发出去，结果积分没增加。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果先发消息，再扣款，可能积分增加了，但钱没扣掉，白送了100积分给人家。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 先扣款，再加积分伪代码：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Transational&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pay() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mysql.payMoney() &lt;span class=&quot;comment&quot;&gt;// 数据库中添加用户信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reduceRepo() &lt;span class=&quot;comment&quot;&gt;// 数据库中减少库存  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-------------------------------------&lt;span class=&quot;comment&quot;&gt;// 若先发消息再加积分，那在这行宕机怎么办？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;producer.send(msg) &lt;span class=&quot;comment&quot;&gt;// 发送100积分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;==&amp;gt; 所以上述方式不可行，我们可以先发送消息（加积分）到Broker，但将消息置为Consumer不可见状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若本地事务（扣款）处理成功了再让Consumer可见&lt;/li&gt;
&lt;li&gt;若本地事务（扣款）失败了就回滚当前消息&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里可能会存在一个问题，生产者本地事务成功后，发送事务确认消息到broker上失败了怎么办？&lt;br&gt;这个时候意味着消费者无法正常消费到这个消息。所以RocketMQ提供了&lt;strong&gt;消息回查机制&lt;/strong&gt;，如果事务消息一直处于中间状态，broker会发起重试去查询broker上这个事务的处理状态。一旦发现事务处理成功，则把当前这条消息设置为可见&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整体的模型图如下：&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMQ】原理分析：消息存储机制</title>
    <link href="https://yzhblog.work/posts/2ca4ccc0.html"/>
    <id>https://yzhblog.work/posts/2ca4ccc0.html</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.862Z</updated>
    
    <content type="html"><![CDATA[<p>由于分布式消息队列对于可靠性的要求比较高，所以需要保证生产者将消息发送到broker之后，保证消息是不出现丢失的，因此消息队列就少不了对于可靠性存储的要求。</p><p>从主流的几种MQ消息队列采用的存储方式来看，主要会有三种 </p><ol><li>分布式KV存储，<ul><li>这种存储方式对于消息读写能力要求不高的情况可以使用 </li><li>比如ActiveMQ中采用的levelDB、Redis，</li></ul></li><li>文件系统存储，<ul><li>这种方案适合对于有高吞吐量要求的消息中间件，因为<strong>消息刷盘是</strong>一种高效率，高可靠、高性能的持久化方式，除非磁盘出现故障，否则一般是不会出现无法持久化的问题 </li><li>常见的比如kafka、RocketMQ、RabbitMQ都是采用消息刷盘到所部署的机器上的文件系统来做持久化</li></ul></li><li>关系型数据库，<ul><li>关系型数据库在单表数据量达到千万级的情况下IO性能会出现瓶颈，</li><li>比如ActiveMQ可以采用mysql作为消息存储，所以ActiveMQ并不适合于高吞吐量的消息队列场景。</li></ul></li></ol><p>总的来说，对于存储效率，文件系统要优于分布式KV存储，分布式KV存储要优于关系型数据库</p><a id="more"></a><h2 id="1-消息存储的整体结构"><a href="#1-消息存储的整体结构" class="headerlink" title="1.消息存储的整体结构"></a>1.消息存储的整体结构</h2><p>RocketMQ的消息存储采用的是混合型的存储结构，也就是Broker单个实例下的所有队列公用一个日志数据文件CommitLog。这个是和Kafka又一个不同之处。 </p><blockquote><p>为什么不采用kafka的设计，针对不同的partition存储一个独立的物理文件呢？<br>这是因为在kafka的设计中，一旦kafka中Topic的Partition数量过多，队列文件会过多，那么会给磁盘的IO读写造成比较大的压力，也就造成了性能瓶颈。所以RocketMQ进行了优化，消息主题统一存储在CommitLog中。</p><ul><li>优点：<ul><li>由于消息主题都是通过CommitLog来进行读写，ConsumerQueue中只存储很少的数据， 所以队列更加轻量化。</li><li>对于磁盘的访问是串行化从而避免了磁盘的竞争</li></ul></li><li>缺点：<ul><li>消息写入磁盘虽然是基于<strong>顺序写</strong>，但是读的过程确是<strong>随机读</strong>。</li><li>读取一条消息会先读取 ConsumeQueue，再读CommitLog，会降低消息读的效率。 </li></ul></li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/202011181936236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-消息的存储文件结构"><a href="#2-消息的存储文件结构" class="headerlink" title="2.消息的存储文件结构"></a>2.消息的存储文件结构</h2><p>RocketMQ就是采用文件系统的方式来存储消息，消息的存储是由ConsumeQueue和CommitLog配合完成的。</p><ul><li>CommitLog是消息真正的物理存储文件。</li><li>ConsumeQueue是消息的逻辑队列，有点类似于数据库的索引文件，里面存储的是指向CommitLog文件中消息存储的地址。 </li></ul><p>RocketMQ的存储文件默认在<code>root/store</code>目录下，可以看到这样一个结构的文件。</p><p><img src="https://img-blog.csdnimg.cn/20201118194421212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>我们只需要关心Commitlog、Consumequeue、Index </p><p><strong>1.CommitLog</strong></p><p>CommitLog是用来存放消息的物理文件，每个broker上的commitLog本当前机器上的所有 consumerQueue共享，不做任何的区分。即所有topic的数据都存在一起</p><ul><li><p>关于文件大小</p><ul><li>CommitLog中的文件默认大小为1G，可以动态配置；</li><li>当一个文件写满以后，会生成一个新的commitlog文件。所有的Topic数据是顺序写入在CommitLog文件中的。 </li></ul></li><li><p>关于文件名</p><ul><li><p>文件名的长度为20位，左边补0，剩余未起始偏移量</p></li><li><p>比如 00000000000000000000 表示第一个文件，</p><p>当第一个文件写满后，生成第二个文件 000000000001073741824 ，起始偏移量为1073741824</p></li></ul></li></ul><p><strong>2.ConsumeQueue</strong></p><p>consumeQueue表示消息消费的逻辑队列，这里面包含MessageQueue在commitlog中的其实物理位置偏移量oﬀset，消息实体内容的大小和Message Tag的hash值。</p><ul><li><p>关于文件大小</p><p>对于实际物理存储来说， consumeQueue对应每个topic和queueid下的文件，每个consumeQueue类型的文件也是有大小，每个文件默认大小约为600W个字节，如果文件满了后会也会生成一个新的文件 </p></li><li><p>关于文件名</p><p>每个Topic下的每个Message Queue都会对应一个ConsumeQueue文件，比如上图中的testCreateTopic3主题下有2个文件夹，分别代表消息队列0和1。</p><p>每个消息队列的文件地址是：<code>root/store/consumequeue/{topicNmae}/{queueId}/{ﬁlename}</code></p></li></ul><p><strong>3.IndexFile</strong></p><p>索引文件，如果一个消息包含Key值的话，会使用IndexFile存储消息索引。Index索引文件提供了对 CommitLog进行数据检索，提供了一种通过key或者时间区间来查找CommitLog中的消息的方法。</p><p>在物理存储中，文件名是以创建的时间戳明明，固定的单个IndexFile大小大概为400M，一个IndexFile可以保存2000W个索引 </p><p><strong>4.abort</strong></p><p>broker在启动的时候会创建一个空的名为abort的文件，并在shutdown时将其删除，用于标识进程是否正常退出，如果不正常退出,会在启动时做故障恢复 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于分布式消息队列对于可靠性的要求比较高，所以需要保证生产者将消息发送到broker之后，保证消息是不出现丢失的，因此消息队列就少不了对于可靠性存储的要求。&lt;/p&gt;
&lt;p&gt;从主流的几种MQ消息队列采用的存储方式来看，主要会有三种 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分布式KV存储，&lt;ul&gt;
&lt;li&gt;这种存储方式对于消息读写能力要求不高的情况可以使用 &lt;/li&gt;
&lt;li&gt;比如ActiveMQ中采用的levelDB、Redis，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件系统存储，&lt;ul&gt;
&lt;li&gt;这种方案适合对于有高吞吐量要求的消息中间件，因为&lt;strong&gt;消息刷盘是&lt;/strong&gt;一种高效率，高可靠、高性能的持久化方式，除非磁盘出现故障，否则一般是不会出现无法持久化的问题 &lt;/li&gt;
&lt;li&gt;常见的比如kafka、RocketMQ、RabbitMQ都是采用消息刷盘到所部署的机器上的文件系统来做持久化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关系型数据库，&lt;ul&gt;
&lt;li&gt;关系型数据库在单表数据量达到千万级的情况下IO性能会出现瓶颈，&lt;/li&gt;
&lt;li&gt;比如ActiveMQ可以采用mysql作为消息存储，所以ActiveMQ并不适合于高吞吐量的消息队列场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说，对于存储效率，文件系统要优于分布式KV存储，分布式KV存储要优于关系型数据库&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMQ】原理分析：消息的可靠性原则</title>
    <link href="https://yzhblog.work/posts/38221343.html"/>
    <id>https://yzhblog.work/posts/38221343.html</id>
    <published>2020-08-21T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.862Z</updated>
    
    <content type="html"><![CDATA[<p>在实际使用RocketMQ的时候我们并不能保证每次发送的消息都刚好能被消费者一次性正常消费成功， 可能会存在需要多次消费才能成功或者一直消费失败的情况，Broker该如何处理呢？ </p><h2 id="1-消息消费端的确认机制"><a href="#1-消息消费端的确认机制" class="headerlink" title="1.消息消费端的确认机制"></a>1.消息消费端的确认机制</h2><p>RocketMQ提供了ack机制（默认是手动ack），以保证消息能够被正常消费。为了保证消息肯定消费成功，只有使用方明确表示消费成功，RocketMQ才会认为消息消费成功，然后删除消息。中途断电，抛出异常等都不会认为成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"my_consumer_group"</span>);</span><br><span class="line">consumer.registerMessageListener((MessageListenerConcurrently) (list, consumeOrderlyContext) -&gt; &#123;</span><br><span class="line">    list.stream().forEach(messageExt -&gt; System.out.println(<span class="keyword">new</span> String(messageExt.getBody()))); </span><br><span class="line">    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS; <span class="comment">// 签收，即手动ack</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所有消费者在设置监听的时候会提供一个回调，业务实现消费回调的时候</p><ul><li>当回调方法中返回 ConsumeConcurrentlyStatus.CONSUME_SUCCESS，RocketMQ才会认为这批消息（默认是1条）是消费完成的。</li><li>如果这时候消息消费失败，例如数据库异常，余额不足扣款失败等一切业务认为消息需要重试的场景，只要返回ConsumeConcurrentlyStatus.RECONSUME_LATER，RocketMQ就会认为这批消息消费失败了 </li></ul><a id="more"></a><h2 id="2-消息的衰减重试"><a href="#2-消息的衰减重试" class="headerlink" title="2.消息的衰减重试"></a>2.消息的衰减重试</h2><p>为了保证消息肯定至少被消费一次，RocketMQ会把这批消息重新发回到broker，在延迟的某个时间点 （默认是10秒，业务可设置）后，再次投递到这个ConsumerGroup。而如果一直这样重复消费都持续失败到一定次数（默认16次），就会投递到DLQ死信队列。  </p><p><img src="https://img-blog.csdnimg.cn/20201118192437115.png#pic_center" alt="在这里插入图片描述"></p><p>应用可以监控死信队列来做人工干预可以修改broker-a.conf文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br></pre></td></tr></table></figure><h2 id="3-重试消息的处理机制"><a href="#3-重试消息的处理机制" class="headerlink" title="3.重试消息的处理机制"></a>3.重试消息的处理机制</h2><p>一般情况下我们在实际生产中是不需要重试16次，这样既浪费时间又浪费性能，而且可能会引起消息堆积（只有前一条确认被消费了，下一条消息才有机会被消费）。理论上当尝试重复次数达到我们想要的结果时如果还是消费失败，那么我们需要将对应消息进行记录，并且结束重复尝试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">consumer.registerMessageListener((MessageListenerConcurrently) (list, consumeOrderlyContext) -&gt; &#123; </span><br><span class="line">    <span class="keyword">for</span> (MessageExt messageExt : list) &#123;  </span><br><span class="line">        <span class="comment">// 如果消息已经重发了3次</span></span><br><span class="line">        <span class="keyword">if</span>(messageExt.getReconsumeTimes()==<span class="number">3</span>) &#123;     </span><br><span class="line">            <span class="comment">// 可以将对应的数据保存到数据库，后续再做处理</span></span><br><span class="line">            System.out.println(messageExt.getMsgId()+<span class="string">","</span>+messageExt.getBody());    </span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;  <span class="comment">// 签收，结束重试   </span></span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在实际使用RocketMQ的时候我们并不能保证每次发送的消息都刚好能被消费者一次性正常消费成功， 可能会存在需要多次消费才能成功或者一直消费失败的情况，Broker该如何处理呢？ &lt;/p&gt;
&lt;h2 id=&quot;1-消息消费端的确认机制&quot;&gt;&lt;a href=&quot;#1-消息消费端的确认机制&quot; class=&quot;headerlink&quot; title=&quot;1.消息消费端的确认机制&quot;&gt;&lt;/a&gt;1.消息消费端的确认机制&lt;/h2&gt;&lt;p&gt;RocketMQ提供了ack机制（默认是手动ack），以保证消息能够被正常消费。为了保证消息肯定消费成功，只有使用方明确表示消费成功，RocketMQ才会认为消息消费成功，然后删除消息。中途断电，抛出异常等都不会认为成功&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DefaultMQPushConsumer consumer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DefaultMQPushConsumer(&lt;span class=&quot;string&quot;&gt;&quot;my_consumer_group&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;consumer.registerMessageListener((MessageListenerConcurrently) (list, consumeOrderlyContext) -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    list.stream().forEach(messageExt -&amp;gt; System.out.println(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(messageExt.getBody()))); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ConsumeConcurrentlyStatus.CONSUME_SUCCESS; &lt;span class=&quot;comment&quot;&gt;// 签收，即手动ack&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所有消费者在设置监听的时候会提供一个回调，业务实现消费回调的时候&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当回调方法中返回 ConsumeConcurrentlyStatus.CONSUME_SUCCESS，RocketMQ才会认为这批消息（默认是1条）是消费完成的。&lt;/li&gt;
&lt;li&gt;如果这时候消息消费失败，例如数据库异常，余额不足扣款失败等一切业务认为消息需要重试的场景，只要返回ConsumeConcurrentlyStatus.RECONSUME_LATER，RocketMQ就会认为这批消息消费失败了 &lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMQ】原理分析：Consumer消费模型、消费规则</title>
    <link href="https://yzhblog.work/posts/44beb96d.html"/>
    <id>https://yzhblog.work/posts/44beb96d.html</id>
    <published>2020-08-20T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-RocketMQ消费模型"><a href="#1-RocketMQ消费模型" class="headerlink" title="1.RocketMQ消费模型"></a>1.RocketMQ消费模型</h2><p>RocketMQ提供了两种消息消费模型，一种是pull主动拉取，另一种是push被动接收。</p><ul><li>实际上 RocketMQ都是pull模式，而push只是在pull模式上做了一层封装</li><li>RocketMQ是基于长轮训来实现消息的pull </li><li>pull到消息以后触发业务消费者注册的call back</li></ul><h2 id="2-消费规则"><a href="#2-消费规则" class="headerlink" title="2.消费规则"></a>2.消费规则</h2><p>我们在<a href="https://blog.csdn.net/weixin_43935927/article/details/109775265" target="_blank" rel="noopener">【RocketMQ】原理分析：Broker集群模式、队列分区</a> 介绍了RocketMQ的多住多从集群模式和通过多个消息队列实现分区。所以如果有一个consumer来了，他到底该在哪个小集群去消费topic下的哪个消息队列？</p><a id="more"></a><h3 id="2-1-master角度"><a href="#2-1-master角度" class="headerlink" title="2.1 master角度"></a>2.1 master角度</h3><p>首先，站在master角度看看Consumer是如何分配拉取消息的。假设有两个master节点的集群，分别是A，B一个消费者组，组中有2个consumer。</p><p><img src="https://img-blog.csdnimg.cn/2020111819131345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>因为master集群数：group中消费者数 = 1:1，所以两个master节点恰好可以平均分发到两个消费者上（比如consumer1消费brokerA的消息，consumer2消费brokerB的消息）</p><p>另外，如果此时只有一个Consumer，那么它会消费两个master节点的数据；如果此时有3个Consumer，那么会有一个Consumer无法消费到消息</p><h3 id="2-2-topic角度"><a href="#2-2-topic角度" class="headerlink" title="2.2 topic角度"></a>2.2 topic角度</h3><p>接下来，站在topic角度看看Consumer是如何分配拉取消息的。假设有两个master节点的集群，创建了一个TestTopic，并且对这个topic创建了两个队列，也就是分区。</p><p><img src="https://img-blog.csdnimg.cn/20201118191349653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>一个消费者可以同时消费多个master节点上的消息，而Topic中的队列数 ：group中的消费者数 = 1:1，所以无论是在哪个group都是一个consumer消费Broker集群中一个队列（比如consumer1消费MQ0，consumer2消费MQ1）</p><blockquote><p>注：消费者定义了两个分组，分组的概念也是和kafka一样，通过分组可以实现消息的广播。每个group中有2个Consumer</p></blockquote><p>另外，如果此时只有一个Consumer，那么它会消费所有分区；如果此时有3个分区，那么就有一个Consumer消费2个分区。</p><h3 id="2-3-动态平衡"><a href="#2-3-动态平衡" class="headerlink" title="2.3 动态平衡"></a>2.3 动态平衡</h3><p>数量关系确定了，那么具体的对应关系是什么呢？比如consumer1到底是消费MQ0还是MQ2。</p><p>和kafka一样，消费端也会针对Message Queue做<strong>负载均衡</strong>，使得每个消费者能够合理的消费多个分区的消息。消费端会通过Rebalance Service线程，10秒钟做一次基于topic下的所有队列负载消费端遍历自己的所有topic，</p><ol><li>依次调rebalanceByTopic 根据topic获取此topic下的所有queue </li><li>选择一台broker获取基于group的所有消费端（有心跳向所有broker注册客户端信息） </li><li>选择队列分配策略实例AllocateMessageQueueStrategy执行分配算法（RocketMQ提供了6中分区的分配算法）<ul><li>AllocateMessageQueueAveragely：平均分配算法（默认）</li><li>AllocateMessageQueueAveragelyByCircle：环状分配消息队列 </li><li>AllocateMessageQueueByConﬁg：按照配置来分配队列： 根据用户指定的配置来进行负载</li><li>AllocateMessageQueueByMachineRoom：按照指定机房来配置队列 </li><li>AllocateMachineRoomNearby：按照就近机房来配置队列： </li><li>AllocateMessageQueueConsistentHash：一致性hash，根据消费者的cid进行 </li></ul></li></ol><p>什么时候触发负载均衡？消费者启动之后消费者数量发生变更 每10秒会触发检查一次rebalance</p><h2 id="3-消息的顺序消费"><a href="#3-消息的顺序消费" class="headerlink" title="3.消息的顺序消费"></a>3.消息的顺序消费</h2><p>通过分区规则可以实现同类消息在rocketmq上的顺序存储。但是对于消费端来说，如何保证消费的顺序？</p><p>前提：生产者 - message queue - 消费者之间是一对一对一的关系。 </p><ol><li>首先，需要保证顺序的消息要发送到同一个message queue中；</li><li>其次，一个message queue只能被一个消费者消费，这点是由消息队列的分配机制来保证的；</li><li>最后，一个消费者内部对一个mq的消费要保证是有序的。</li></ol><p>在RocketMQ的api中对每个Consumer提供了两种消费方式：</p><ul><li><code>MessageListenerConcurrently</code> ：并发监听，也就是基于多个线程并行来消费消息。这个无法保证消息消费的顺序</li><li><code>MessageListenerOrderly</code>：顺序消费，单线程去消费消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"my_consumer_group"</span>);</span><br><span class="line">consumer.subscribe(<span class="string">"store_topic_test"</span>,<span class="string">"*"</span>);</span><br><span class="line">consumer.registerMessageListener((MessageListenerOrderly) (list, consumeOrderlyContext) -&gt; &#123;  </span><br><span class="line">    list.stream().forEach(messageExt -&gt; System.out.println(<span class="keyword">new</span> String(messageExt.getBody())));   </span><br><span class="line">    <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>顺序消费会带来一些问题，  </p><ol><li>遇到消息失败的消息，无法跳过，当前队列消费暂停 </li><li>降低了消息处理的性能</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-RocketMQ消费模型&quot;&gt;&lt;a href=&quot;#1-RocketMQ消费模型&quot; class=&quot;headerlink&quot; title=&quot;1.RocketMQ消费模型&quot;&gt;&lt;/a&gt;1.RocketMQ消费模型&lt;/h2&gt;&lt;p&gt;RocketMQ提供了两种消息消费模型，一种是pull主动拉取，另一种是push被动接收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际上 RocketMQ都是pull模式，而push只是在pull模式上做了一层封装&lt;/li&gt;
&lt;li&gt;RocketMQ是基于长轮训来实现消息的pull &lt;/li&gt;
&lt;li&gt;pull到消息以后触发业务消费者注册的call back&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-消费规则&quot;&gt;&lt;a href=&quot;#2-消费规则&quot; class=&quot;headerlink&quot; title=&quot;2.消费规则&quot;&gt;&lt;/a&gt;2.消费规则&lt;/h2&gt;&lt;p&gt;我们在&lt;a href=&quot;https://blog.csdn.net/weixin_43935927/article/details/109775265&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【RocketMQ】原理分析：Broker集群模式、队列分区&lt;/a&gt; 介绍了RocketMQ的多住多从集群模式和通过多个消息队列实现分区。所以如果有一个consumer来了，他到底该在哪个小集群去消费topic下的哪个消息队列？&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMQ】原理分析：Producer消息发送模式、分发规则</title>
    <link href="https://yzhblog.work/posts/882763e9.html"/>
    <id>https://yzhblog.work/posts/882763e9.html</id>
    <published>2020-08-20T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-消息发送模式"><a href="#1-消息发送模式" class="headerlink" title="1.消息发送模式"></a>1.消息发送模式</h2><h3 id="1-1-同步发送"><a href="#1-1-同步发送" class="headerlink" title="1.1 同步发送"></a>1.1 同步发送</h3><p>同步消息发送模式就是说消息发送出去后，producer会等到broker回应后才能继续发送下一个消息</p><p><img src="https://img-blog.csdnimg.cn/20201118155209946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"my_producer_group"</span>);</span><br><span class="line">producer.send(message); <span class="comment">// 同步发送</span></span><br></pre></td></tr></table></figure><p>返回的SendResult有四种状态：SEND OK（成功），FLUSH_DISK_TIMEOUT（刷盘超时），FLUSH_SLAVE_TIMEOUT（同步超时），SLAVE_NOT_AVAILABLE，</p><a id="more"></a><h3 id="1-2-异步发送"><a href="#1-2-异步发送" class="headerlink" title="1.2 异步发送"></a>1.2 异步发送</h3><p>异步发送是指发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</p><p><img src="https://img-blog.csdnimg.cn/20201118155224649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>MQ 的异步发送，需要用户实现异步发送回调接口（SendCallback）。消息发送方在发送了一条消息后，不需要等待服务器响应即可返回，进行第二条消息发送。发送方通过回调接口接收服务器响应，并对响应结果进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"my_producer_group"</span>);</span><br><span class="line">producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;    </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 成功回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;    </span><br><span class="line">        System.out.printf(<span class="string">"%s%n"</span>,sendResult);  </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 失败回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable throwable)</span> </span>&#123;     </span><br><span class="line">        throwable.printStackTrace();  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-3-单向发送"><a href="#1-3-单向发送" class="headerlink" title="1.3 单向发送"></a>1.3 单向发送</h3><p>单向（Oneway）发送特点为发送方只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答.效率最高</p><p><img src="https://img-blog.csdnimg.cn/20201118155251357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"my_producer_group"</span>);</span><br><span class="line">producer.sendOneway(msg);</span><br></pre></td></tr></table></figure><h3 id="1-4-顺序发送"><a href="#1-4-顺序发送" class="headerlink" title="1.4 顺序发送"></a>1.4 顺序发送</h3><p>在kafka中，消息可以通过自定义分区策略来实现消息的顺序发送，实现原理就是把同一类消息都发送到相同的分区上。</p><p>在RocketMQ中，是<strong>基于多个Message Queue来实现类似于kafka的分区效果</strong>。如果一个Topic 要发送和接收的数据量非常大， 需要能支持增加并行处理的机器来提高处理速度，这时候一个Topic 可以根据需求设置一个或多个Message Queue。Topic 有了多个Message Queue 后，消息可以并行地向各个 Message Queue 发送，消费者也可以并行地从多个Message Queue 读取消息并消费。</p><h2 id="2-分发规则"><a href="#2-分发规则" class="headerlink" title="2.分发规则"></a>2.分发规则</h2><h3 id="2-1-默认规则"><a href="#2-1-默认规则" class="headerlink" title="2.1 默认规则"></a>2.1 默认规则</h3><p>通过自定义发送策略来实现消息只发送到同一个队列，因为一个Topic 会有多个Message Queue ，如果使用Producer 的默认配置，这个Producer 会轮流向各个Message Queue 发送消息。Consumer 在消费消息的时候，会根据负载均衡策略，消费被分配到的Message Queue。</p><h3 id="2-2-自定义"><a href="#2-2-自定义" class="headerlink" title="2.2 自定义"></a>2.2 自定义</h3><p>如果不经过特定的设置，某条消息被发往哪个Message Queue ，被哪个Consumer 消费是未知的。如果业务需要我们把消息发送到指定的Message Queue 里，比如把同一类型的消息都发往相同的 Message Queue。那是不是可以实现顺序消息的功能呢？</p><p>和kafka一样，rocketMQ也提供了消息路由的功能，我们可以自定义消息分发策略，通过实现 MessageQueueSelector，来实现自己的消息分发策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"my_producer_group"</span>);</span><br><span class="line">SendResult sendResult = producer.send(msg, <span class="keyword">new</span> MessageQueueSelector() &#123;    </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">select</span><span class="params">(List&lt;MessageQueue&gt; list, Message message, Object o)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> key=o.hashCode();     </span><br><span class="line">        <span class="keyword">int</span> size = list.size(); <span class="comment">// 当前topic的消息队列数</span></span><br><span class="line">        <span class="keyword">int</span> index = key%size;   <span class="comment">// 目标队列索引   </span></span><br><span class="line">        <span class="keyword">return</span> list.get(index); <span class="comment">// list.get(0);   </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">"key_"</span>+i);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-消息发送模式&quot;&gt;&lt;a href=&quot;#1-消息发送模式&quot; class=&quot;headerlink&quot; title=&quot;1.消息发送模式&quot;&gt;&lt;/a&gt;1.消息发送模式&lt;/h2&gt;&lt;h3 id=&quot;1-1-同步发送&quot;&gt;&lt;a href=&quot;#1-1-同步发送&quot; class=&quot;headerlink&quot; title=&quot;1.1 同步发送&quot;&gt;&lt;/a&gt;1.1 同步发送&lt;/h3&gt;&lt;p&gt;同步消息发送模式就是说消息发送出去后，producer会等到broker回应后才能继续发送下一个消息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201118155209946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DefaultMQProducer producer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DefaultMQProducer(&lt;span class=&quot;string&quot;&gt;&quot;my_producer_group&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;producer.send(message); &lt;span class=&quot;comment&quot;&gt;// 同步发送&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回的SendResult有四种状态：SEND OK（成功），FLUSH_DISK_TIMEOUT（刷盘超时），FLUSH_SLAVE_TIMEOUT（同步超时），SLAVE_NOT_AVAILABLE，&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMQ】原理分析：Broker集群模式、队列分区</title>
    <link href="https://yzhblog.work/posts/4731858c.html"/>
    <id>https://yzhblog.work/posts/4731858c.html</id>
    <published>2020-08-20T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Broker集群模式（宏观）"><a href="#1-Broker集群模式（宏观）" class="headerlink" title="1.Broker集群模式（宏观）"></a>1.Broker集群模式（宏观）</h2><p>RocketMQ天生对集群的支持非常友好，天然支持高可用，它可以支持<strong>多主多从</strong>的部署架构，这也是和kafka大区别之一。</p><p><img src="https://img-blog.csdnimg.cn/2020111819163045.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>那为什么要将这么多broker组织成多主多从，而不是采用一主多从然后主节点down机后再选举啊？因为。。。RocketMQ中并没有master选举功能，在RocketMQ集群中，1台机器只能要么是Master，要么是Slave，这个在初始的机器配置里面，就定死了。不会像kafka那样存在master动态选举的功能，所以通过配置多个master节点来保证rocketMQ的高可用。</p><blockquote><p>其中Master的broker id = 0，Slave 的broker id &gt; 0。 有点类似于mysql的主从概念，master挂了以后，slave仍然可以提供读服务，但是由于有多主的存在，当一个master挂了以后，可以写到其他的master上。 </p></blockquote><p>和所有的集群角色定位一样，master节点负责接受事务请求、slave节点只负责接收读请求，并且接收master同步过来的数据和slave保持一致。</p><a id="more"></a><blockquote><p>既然说到集群模式了，那我们再来看看常见的四种集群模式：</p><ol><li>单Master<pre><code>- 优点：除了配置简单没什么优点- 缺点：不可靠，该机器重启或宕机，将导致整个服务不可用</code></pre></li><li>多Master<pre><code> - 优点：配置简单，性能高- 缺点：可能会有少量消息丢失（配置相关），单台机器重启或宕机期间，该机器下未被消费的消息在机器恢复前不可订阅，影响消息实时性</code></pre></li><li>多Master多Slave，每个Master配一个Slave，有多对Master-Slave，集群采用异步复制方式，主备有短暂消息延迟，毫秒级<pre><code>- 优点：性能同多Master几乎一样，实时性高，主备间切换对应用透明，不需人工干预    - 缺点：Master宕机或磁盘损坏时会有少量消息丢失</code></pre></li><li>多Master多Slave，每个Master配一个Slave，有多对Master-Slave，集群采用同步双写方式，主备都写成功，向应用返回成功<pre><code>- 优点：服务可用性与数据可用性非常高- 缺点：性能比异步集群略低，当前版本主宕备不能自动切换为主</code></pre></li></ol></blockquote><p>而RocketMQ采用的就是的第三种。在多主多从架构下，由于每个master可以配置多个slave，所以如果其中一个master挂了，那么只是当前Broker不能写消息了，但Consumer仍然可以从slave节点消费到。可以完美的实现rocketmq消息的高可用。</p><ul><li>如果当前rocketmq是一主多从，就意味着无法接受发送端的消息，但是消费者仍然能够继续消费。</li><li>如果当前rocketmq是多主多从，另外一个master节点仍然能够对外提供消息发送服务。</li></ul><p>这里特别注意一点，当存在多个主节点时，一条消息只会发送到其中一个主节点。rocketmq对于多个master节点的消息发送，会做负载均衡，使得消息可以平衡的发送到多个master节点上。 一个消费者可以同时消费多个master节点上的消息，在上面这个架构图中，两个master节点恰好可以 平均分发到两个消费者上，如果此时只有一个消费者，那么这个消费者会消费两个master节点的数据。</p><h2 id="2-Broker队列分区（微观）"><a href="#2-Broker队列分区（微观）" class="headerlink" title="2.Broker队列分区（微观）"></a>2.Broker队列分区（微观）</h2><p>在RocketMQ中，是基于多个Message Queue来实现类似于kafka的分区效果。如果一个Topic 要发送和接收的数据量非常大， 需要能支持增加并行处理的机器来提高处理速度，这时候一个Topic 可以根据需求设置一个或多个Message Queue。</p><p>Topic 有了多个Message Queue 后，消息可以并行地向各个 Message Queue 发送，消费者也可以并行地从多个Message Queue 读取消息并消费。从而提高消费者并发处理的能力与消费者拉取消息时的负载均衡</p><blockquote><p>注：RocketMQ是通过多Master实现了对Producer发送消息的负载均衡，而不是kafka那样通过分区分片存储实现Producer发消息负载均衡</p></blockquote><p>我们可以直接在控制台创建队列（分区）：</p><p><img src="https://img-blog.csdnimg.cn/20201118154316267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>图中那两个参数是什么意思呢？</p><ul><li>writeQueueNums：写队列数，表示producer发送到的MessageQueue的队列个数</li><li>readQueueNums：读队列数，表示Consumer读取消息的MessageQueue队列个数</li></ul><p>注：这两个值<strong>需要相等</strong>，在集群模式下如果不相等，writeQueueNums=6,readQueueNums=3, 那么每个broker上会有3个queue的消息是无法消费的。 </p></blockquote><p>上面创建一个TestTopic的主题，这个主题下有两个队列，即两个分区。</p><ul><li>为了Producer发来的消息每个master都能写，所以每个Broker上都要有TestTopic主题</li><li>而且每个Broker上的TestTopic，都要有两个分区</li></ul><p><img src="https://img-blog.csdnimg.cn/20201118185743112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>注：类似于kafka，分区 + Consumer group ==&gt; 对于consumer的消息广播。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-Broker集群模式（宏观）&quot;&gt;&lt;a href=&quot;#1-Broker集群模式（宏观）&quot; class=&quot;headerlink&quot; title=&quot;1.Broker集群模式（宏观）&quot;&gt;&lt;/a&gt;1.Broker集群模式（宏观）&lt;/h2&gt;&lt;p&gt;RocketMQ天生对集群的支持非常友好，天然支持高可用，它可以支持&lt;strong&gt;多主多从&lt;/strong&gt;的部署架构，这也是和kafka大区别之一。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020111819163045.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;那为什么要将这么多broker组织成多主多从，而不是采用一主多从然后主节点down机后再选举啊？因为。。。RocketMQ中并没有master选举功能，在RocketMQ集群中，1台机器只能要么是Master，要么是Slave，这个在初始的机器配置里面，就定死了。不会像kafka那样存在master动态选举的功能，所以通过配置多个master节点来保证rocketMQ的高可用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中Master的broker id = 0，Slave 的broker id &amp;gt; 0。 有点类似于mysql的主从概念，master挂了以后，slave仍然可以提供读服务，但是由于有多主的存在，当一个master挂了以后，可以写到其他的master上。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和所有的集群角色定位一样，master节点负责接受事务请求、slave节点只负责接收读请求，并且接收master同步过来的数据和slave保持一致。&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMQ】设计思路、架构模型</title>
    <link href="https://yzhblog.work/posts/23bffa8.html"/>
    <id>https://yzhblog.work/posts/23bffa8.html</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-消息中间件的设计"><a href="#1-消息中间件的设计" class="headerlink" title="1.消息中间件的设计"></a>1.消息中间件的设计</h2><ul><li>可以先从基本的需求开始思考<ul><li>基本的是要能支持消息的发送和接收，需要涉及到网络通信就一定会涉及到NIO </li><li>消息中心的消息存储（持久化/非持久化） </li><li>消息的序列化和反序列化 </li><li>是否跨语言 </li><li>消息的确认机制，如何避免消息重发</li></ul></li><li>高级功能</li><li>消息的有序性 </li><li>是否支持事务消息 </li><li>消息收发的性能，对高并发大数据量的支持 </li><li>是否支持集群 </li><li>消息的可靠性存储 </li><li>是否支持多协议</li></ul><a id="more"></a><h2 id="2-MQ消息存储选择"><a href="#2-MQ消息存储选择" class="headerlink" title="2.MQ消息存储选择"></a>2.MQ消息存储选择</h2><p>从主流的几种MQ消息队列采用的存储方式来看，主要会有三种 </p><ol><li>分布式KV存储，比如ActiveMQ中采用的levelDB、Redis， 这种存储方式对于消息读写能力要求不高的情况可以使用 </li><li>文件系统存储，常见的比如kafka、RocketMQ、RabbitMQ都是采用消息刷盘到所部署的机器上的文件系统来做持久化，这种方案适合对于有高吞吐量要求的消息中间件，因为消息刷盘是一种高效率，高可靠、高性能的持久化方式，除非磁盘出现故障，否则一般是不会出现无法持久化的问题 </li><li>关系型数据库，比如ActiveMQ可以采用mysql作为消息存储，关系型数据库在单表数据量达到千万级的情况下IO性能会出现瓶颈，所以ActiveMQ并不适合于高吞吐量的消息队列场景。</li></ol><p>总的来说，对于存储效率，文件系统要优于分布式KV存储，分布式KV存储要优于关系型数据库 </p><h2 id="3-RocketMQ简介"><a href="#3-RocketMQ简介" class="headerlink" title="3.RocketMQ简介"></a>3.RocketMQ简介</h2><p>RocketMq是一个由阿里巴巴开源的消息中间件， 2012年开源，2017年成为apache顶级项目。</p><p>它的核心设计借鉴了Kafka，所以我们在了解RocketMQ的时候，会发现很多和kafka相同的特性。同时，Rocket在某些功能上和kafka又有较大的差异，下面是RocketMQ的特性：</p><ol><li>支持集群模型、负载均衡、水平扩展能力 </li><li>亿级别消息堆积能力 </li><li>采用零拷贝的原理，顺序写盘，随机读 </li><li>底层通信框架采用Netty NIO </li><li>NameServer代替Zookeeper，实现服务寻址和服务协调 </li><li>消息失败重试机制、消息可查询 </li><li>强调集群无单点，可扩展，任意一点高可用，水平可扩展 </li><li>经过多次双十一的考验 </li></ol><h2 id="4-RocketMQ架构"><a href="#4-RocketMQ架构" class="headerlink" title="4.RocketMQ架构"></a>4.RocketMQ架构</h2><p><img src="https://img-blog.csdnimg.cn/20201118133114233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>集群本身没有什么特殊之处，和kafka的整体架构类似，其中zookeeper替换成了NameServer。</p><p>在rocketmq的早版本（2.x）的时候，是没有namesrv组件的，用的是zookeeper做分布式协调和服务发现，但是后期阿里数据根据实际业务需求进行改进和优化，自组研发了轻量级的 namesrv,用于注册Client服务与Broker的请求路由工作，namesrv上不做任何消息的位置存储， 频繁操作zookeeper的位置存储数据会影响整体集群性能 </p><p>RocketMQ由四部分组成：</p><ul><li><p>Name Server：提供轻量级的服务发现和路由，可集群部署，节点之间无任何信息同步。</p></li><li><p>Broker：消息中转角色，负责存储消息转发消息，部署相对复杂。Broker 分为Master 与Slave</p><ul><li>Master 与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0 表示Master，非0 表示Slave。 </li><li>一 个Master 可以对应多个Slave，但是一个Slave 只能对应一个Master。Master 也可以部署多个。</li></ul></li><li><p>Producer：生产者</p><ul><li>拥有相同 Producer Group 的 Producer 组成一个集群，</li><li>与Name Server 集群中的其中一个节点（随机选择）建立长连接，定期从Name Server 取Topic 路由信息</li><li>向提供Topic 服务的Master 建立长连接，且定时向Master 发送心跳。</li><li>Producer 完全无状态，可集群部署。 </li></ul></li><li><p>Consumer：消费者，接收消息进行消费的实例</p><ul><li>拥有相同 Consumer Group 的 Consumer 组成 一个集群</li><li>与Name Server 集群中的其中一个节点（随机选择）建立长连接，定期从Name Server 取 Topic 路由信息</li><li>向提供Topic 服务的Master、Slave 建立长连接，且定时向Master、Slave 发送心跳。</li></ul><p>Consumer既可以从Master 订阅消息，也可以从Slave 订阅消息，订阅规则由Broker 配置决定。</p><p>要使用rocketmq，至少需要启动两个进程，nameserver、broker，前者是各种topic注册中心，后者是真正的broker。 </p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-消息中间件的设计&quot;&gt;&lt;a href=&quot;#1-消息中间件的设计&quot; class=&quot;headerlink&quot; title=&quot;1.消息中间件的设计&quot;&gt;&lt;/a&gt;1.消息中间件的设计&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以先从基本的需求开始思考&lt;ul&gt;
&lt;li&gt;基本的是要能支持消息的发送和接收，需要涉及到网络通信就一定会涉及到NIO &lt;/li&gt;
&lt;li&gt;消息中心的消息存储（持久化/非持久化） &lt;/li&gt;
&lt;li&gt;消息的序列化和反序列化 &lt;/li&gt;
&lt;li&gt;是否跨语言 &lt;/li&gt;
&lt;li&gt;消息的确认机制，如何避免消息重发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高级功能&lt;/li&gt;
&lt;li&gt;消息的有序性 &lt;/li&gt;
&lt;li&gt;是否支持事务消息 &lt;/li&gt;
&lt;li&gt;消息收发的性能，对高并发大数据量的支持 &lt;/li&gt;
&lt;li&gt;是否支持集群 &lt;/li&gt;
&lt;li&gt;消息的可靠性存储 &lt;/li&gt;
&lt;li&gt;是否支持多协议&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMQ】基本使用：Java操作RocketMQ（rocketmq-client）</title>
    <link href="https://yzhblog.work/posts/b4ec5299.html"/>
    <id>https://yzhblog.work/posts/b4ec5299.html</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-Producer"><a href="#2-Producer" class="headerlink" title="2.Producer"></a>2.Producer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 构造Producer时，必须指定groupId</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"my_producer_group"</span>);</span><br><span class="line">        <span class="comment">// 只用namesrv的地址就行，它会从namesrv上拿到broker的地址和topic信息</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">"39.105.136.112:9876"</span>); </span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            num++;</span><br><span class="line">             <span class="comment">/**</span></span><br><span class="line"><span class="comment">              * rocketmq封装了Message</span></span><br><span class="line"><span class="comment">           * String topic, </span></span><br><span class="line"><span class="comment">           * String tags, 标签（分类）---&gt; 筛选</span></span><br><span class="line"><span class="comment">           * byte[] body</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">"my_test_topic"</span>, <span class="string">""</span>, (<span class="string">"hello rocketmq:"</span> + num).getBytes());</span><br><span class="line">            <span class="comment">// 发送消息，拿到返回SendResult</span></span><br><span class="line">            SendResult result = producer.send(message); </span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>启动并发送消成功后，返回的SendResult如下：</p><p><img src="https://img-blog.csdnimg.cn/20201118152648192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>SendResult中，有一个sendStatus状态，表示消息的发送状态。一共有四种状态 </p><ul><li>FLUSH_DISK_TIMEOUT ： 表示没有在规定时间内完成刷盘（需要Broker 的刷盘策Ill创立设置成 SYNC_FLUSH 才会报这个错误） 。</li><li>FLUSH_SLAVE_TIMEOUT ：表示在主备方式下，并且Broker 被设置成SYNC_MASTER 方式，没有在设定时间内完成主从同步。</li><li>SLAVE_NOT_AVAILABLE ： 这个状态产生的场景和FLUSH_SLAVE_TIMEOUT 类似， 表示在主备方式下，并且Broker 被设置成SYNC_MASTER ，但是没有找到被配置成Slave 的Broker 。 </li><li>SEND OK ：表示发送成功，发送成功的具体含义，比如消息是否已经被存储到磁盘？消息是否被同步到了Slave 上？消息在Slave 上是否被写入磁盘？需要结合所配置的刷盘策略、主从策略来定。这个状态还可以简单理解为，没有发生上面列出的三个问题状态就是SEND OK</li></ul><p><img src="https://img-blog.csdnimg.cn/20201118152742219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="3-Consumer"><a href="#3-Consumer" class="headerlink" title="3.Consumer"></a>3.Consumer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">// 构造Consumer时，必须指定groupId</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">"my_consumer_group"</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">"39.105.136.112:9876"</span>); <span class="comment">// nameServer地址,用于获取broker、topic信息</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        <span class="comment">// 指定订阅的主题与tag，通过tag可以定制性消费（*表示全部tag）</span></span><br><span class="line">        consumer.subscribe(<span class="string">"my_test_topic"</span>, <span class="string">"*"</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步消费</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Receive Message:"</span> + msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS; <span class="comment">// 签收</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到消息的内容：</p><p><img src="https://img-blog.csdnimg.cn/2020111815355513.png#pic_center" alt="在这里插入图片描述"></p><p>consumer Group：位于同一个consumer Group中的consumer实例</p><ul><li>和producer Group中的各个produer实例承担的角色类似</li><li>同一个group中可以配置多个consumer，可以提高消费端的并发<strong>消费能力</strong>以及容灾</li><li>和kafka一样，多个consumer会对消息做<strong>负载均衡</strong>，意味着同一个topic下的不同messageQueue会分发给同一个group中的不同consumer。 </li><li>同时，如果我们希望消息能够达到<strong>广播</strong>的目的，那么只需要把consumer加入到不同的group就行。</li></ul><p><img src="https://img-blog.csdnimg.cn/20201118153647548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-引入依赖&quot;&gt;&lt;a href=&quot;#1-引入依赖&quot; class=&quot;headerlink&quot; title=&quot;1.引入依赖&quot;&gt;&lt;/a&gt;1.引入依赖&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.rocketmq&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;rocketmq-client&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;4.5.2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;2-Producer&quot;&gt;&lt;a href=&quot;#2-Producer&quot; class=&quot;headerlink&quot; title=&quot;2.Producer&quot;&gt;&lt;/a&gt;2.Producer&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyProducer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 构造Producer时，必须指定groupId&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DefaultMQProducer producer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DefaultMQProducer(&lt;span class=&quot;string&quot;&gt;&quot;my_producer_group&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 只用namesrv的地址就行，它会从namesrv上拿到broker的地址和topic信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        producer.setNamesrvAddr(&lt;span class=&quot;string&quot;&gt;&quot;39.105.136.112:9876&quot;&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        producer.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (num &amp;lt; &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            num++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;              * rocketmq封装了Message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     	      * String topic, &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     	      * String tags, 标签（分类）---&amp;gt; 筛选&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     	      * byte[] body&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     	      */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Message message = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Message(&lt;span class=&quot;string&quot;&gt;&quot;my_test_topic&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, (&lt;span class=&quot;string&quot;&gt;&quot;hello rocketmq:&quot;&lt;/span&gt; + num).getBytes());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 发送消息，拿到返回SendResult&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            SendResult result = producer.send(message); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RocketMQ】基本使用：安装、使用、可视控制台（阿里云搭建踩坑记录）</title>
    <link href="https://yzhblog.work/posts/1cdc2110.html"/>
    <id>https://yzhblog.work/posts/1cdc2110.html</id>
    <published>2020-08-19T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>1).下载安装包</p><p>下载地址：<a href="http://rocketmq.apache.org/dowloading/releases/" target="_blank" rel="noopener">http://rocketmq.apache.org/dowloading/releases/</a></p><p><img src="https://img-blog.csdnimg.cn/20201118134212642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>2). 解压</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip rocketmq-all-4.5.0-bin-release.zip</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p><strong>1). 启动 nameserver</strong></p><p>默认情况下，nameserver监听的是9876端口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nohup sh namesrv &amp; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 若在云服务器，那么启动时要-n加上公网IP</span></span><br><span class="line">nohup sh namesrv -n 39.105.136.112:9876 &amp;</span><br></pre></td></tr></table></figure><p>两点注意：</p><ul><li>日志在用户目录下（root/logs），查看启动日志<code>tail -f ~/logs/rocketmqlogs/namesrv.log</code></li></ul><p><img src="https://img-blog.csdnimg.cn/20201118134459839.png#pic_center" alt="在这里插入图片描述"></p><ul><li><p>若启动时内存不足，需要修改JVM相关配置 <code>vim runserver.sh</code>，修改原来的4g为1g<br>   <img src="https://img-blog.csdnimg.cn/20201118141453160.png#pic_center" alt="在这里插入图片描述"></p><blockquote><ul><li>Xms 是指设定程序启动时占用内存大小。一般来讲，大点，程序会启动的快一点，但是也可能会导致机器暂时 间变慢。 </li><li>Xmx 是指设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值， 就会抛出OutOfMemory异常。 </li><li>xmn  年轻代的heap大小，一般设置为Xmx的3、4分之一</li></ul></blockquote></li></ul><p><strong>2). 启动broker</strong></p><p>默认情况下，broker监听的是10911端口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -n localhost:9876 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若在云服务器还需加上： -n 公网IP -c 配置文件 auto..=true</span></span><br><span class="line">nohup sh mqbroker -n 39.105.136.112:9876 -c ../conf/broker.conf autoCreateTopicEnable=<span class="literal">true</span> &amp;</span><br></pre></td></tr></table></figure><p>特别注意以下两点：</p><ul><li><p>若是云服务器，需要将公网IP配置进broker.conf，<code>brokerIP=公网IP</code></p><p><img src="https://img-blog.csdnimg.cn/20201118141728485.png#pic_center" alt="在这里插入图片描述"></p></li></ul><ul><li><p><code>tail -f ~/logs/rocketmqlogs/broker.log</code> 查看日志，如果提示找不到文件，则打开当前目录下的 nohup.out 日志文件查看，出现如下日志表示启动失败，提示内存无法分配。修改所需内存<code>vim runbroker.sh</code>，修改8g为512m</p><p><img src="https://img-blog.csdnimg.cn/20201118144033681.png#pic_center" alt="在这里插入图片描述"></p></li></ul><p><strong>3). 停止服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh mqshutdown broker</span><br><span class="line">sh mqshutdown namesrv</span><br></pre></td></tr></table></figure><h2 id="3-broker-conf文件分析"><a href="#3-broker-conf文件分析" class="headerlink" title="3.broker.conf文件分析"></a>3.broker.conf文件分析</h2><p>默认情况下，启动broker会加载conf/broker.conf文件，这个文件里面就是一些常规的配置信息 </p><p><img src="https://img-blog.csdnimg.cn/20201118145726180.png#pic_center" alt="在这里插入图片描述"></p><ul><li>brokerClusterName：Cluster名称，如果集群机器数比较多，可以分成多个cluster，每个cluster提供 给不同的业务场景使用</li><li>brokerName：broker名称，如果配置主从模式，master和slave需要配置相同的名称来表名关系</li><li>brokerId=0：在主从模式中，一个master broker可以有多个slave，0表示master，大于0表示不同 slave的id</li><li>brokerRole=SYNC_MASTER/ASYNC_MASTER/SLAVE：表示slave和master消息同步完成后再返回信息给客户端</li><li>autoCreateTopicEnable = true：topic不存在的情况下自动创建 </li></ul><h2 id="4-可视控制台"><a href="#4-可视控制台" class="headerlink" title="4.可视控制台"></a>4.可视控制台</h2><p>rocket官方提供了一个可视化控制台，地址：<a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">https://github.com/apache/rocketmq-externals</a>。这个是rocketmq的扩展，里面不仅包含控制台的扩展，也包含对大数据ﬂume、hbase等组件的对接和扩展。 </p><p><img src="https://img-blog.csdnimg.cn/20201118145825185.png#pic_center" alt="在这里插入图片描述"></p><p><strong>1.安装</strong></p><p>1). 下载源码包并解压</p><p>   注：其实对于rocketmq而言，直接用git clone只下载rocketmq-console也行</p><p>2). 修改rocketmq-console项目中的application.properties 的<code>namesrvAddr</code>属性</p><p><img src="https://img-blog.csdnimg.cn/20201118145839226.png#pic_center" alt="在这里插入图片描述"></p><p>3). 在rocketmq-console目录下打开命令行，启动springboot项目<code>mvn spring-boot:run</code></p><p>   注：若命令行关闭，服务就停了</p><p><img src="https://img-blog.csdnimg.cn/20201118145853694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>2.使用</strong></p><p>在浏览器8080端口进行访问</p><ol><li>首页：</li></ol><p><img src="https://img-blog.csdnimg.cn/20201118145906562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol start="2"><li>topic：</li></ol><p><img src="https://img-blog.csdnimg.cn/20201118153252651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol start="3"><li>Consumer：</li></ol><p><img src="https://img-blog.csdnimg.cn/20201118145940466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1.安装&quot;&gt;&lt;/a&gt;1.安装&lt;/h2&gt;&lt;p&gt;1).下载安装包&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://rocketmq.apache.org/dowloading/releases/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://rocketmq.apache.org/dowloading/releases/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201118134212642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;2). 解压&lt;/p&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;unzip rocketmq-all-4.5.0-bin-release.zip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RabbitMQ】几个面试题</title>
    <link href="https://yzhblog.work/posts/78bf5902.html"/>
    <id>https://yzhblog.work/posts/78bf5902.html</id>
    <published>2020-08-17T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-RabbitMQ基本使用问题"><a href="#一-RabbitMQ基本使用问题" class="headerlink" title="一.RabbitMQ基本使用问题"></a>一.RabbitMQ基本使用问题</h2><blockquote><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/weixin_43935927/article/details/109661259" target="_blank" rel="noopener">【消息队列】五个问题详解消息中间件</a></li><li><a href="https://blog.csdn.net/weixin_43935927/article/details/109712002" target="_blank" rel="noopener">【RabbitMQ】基本特性、工作模型、路由方式</a></li></ul></blockquote><p><strong>1.消息队列的作用与使用场景？</strong></p><p>异步、解耦、削峰 + 具体应用场景。</p><p><strong>2.Channel和vhost的作用是什么？</strong></p><ul><li>Channel：减少TCP资源的消耗。也是最重要的编程接口。</li><li>Vhost：提高硬件资源利用率，实现资源隔离。</li></ul><p><strong>3.RabbitMQ的消息有哪些路由方式？适合在什么业务场景使用？</strong></p><p>Direct、Topic、Fanout</p><p><strong>4.交换机与队列、队列与消费者的绑定关系是什么样的？</strong></p><p>多对多</p><a id="more"></a><h2 id="二-RabbitMQ高级特性问题"><a href="#二-RabbitMQ高级特性问题" class="headerlink" title="二.RabbitMQ高级特性问题"></a>二.RabbitMQ高级特性问题</h2><blockquote><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/weixin_43935927/article/details/109742645" target="_blank" rel="noopener">【RabbitMQ】原理分析：如何保证消息可靠性投递？</a></li><li><a href="https://blog.csdn.net/weixin_43935927/article/details/109731396" target="_blank" rel="noopener">【RabbitMQ】高级使用：消息过期设置、死信队列、延迟队列、流控</a></li><li><a href="https://blog.csdn.net/weixin_43935927/article/details/109737660" target="_blank" rel="noopener">【RabbitMQ】基本使用：Java操作RabbitMQ–Spring AMQP核心组件解析</a></li><li><a href="https://blog.csdn.net/weixin_43935927/article/details/109749429" target="_blank" rel="noopener">【RabbitMQ】高级使用：补偿机制、消息幂等性、最终一致性、消息顺序性</a></li></ul></blockquote><p><strong>5.多个消费者监听一个队列时（比如一个服务部署多个实例），消息会重复消费吗？</strong></p><p>队列中的消息会被平均<strong>分摊</strong>(轮询)给多个消费者进行处理，而不是每个消费者都收到所有的消息。RabbitMQ不支持队列层面的广播消费，如果需要广播消费，需要在其上进行二次开发，处理起来异常复杂。</p><p>注：这点kafka与rabbitmq不同，kafka只要Consumer有不同的groupId，那么就可以重复消费同一topic下的消息</p><p><strong>6.无法被路由的消息，去了哪里？</strong></p><ul><li>直接丢弃</li><li>回发</li><li>可用备份交换机（alternate-exchange）接收</li></ul><p><strong>7.消息在什么时候会变成 Dead Letter（死信）</strong></p><ul><li>消息过期；</li><li>消息超过队列长度或容量；</li><li>消息被拒绝并且未设置重回队列</li></ul><p><strong>8.如果一个项目要从多个服务器接收消息，怎么做？如果一个项目要发送消息到多个服务器，怎么做？</strong></p><p>定义多个ConnectionFactory，注入到消费者监听类/Temaplate。</p><p><strong>9.RabbitMQ如何实现延迟队列？</strong></p><ul><li>基于数据库+定时任务；</li><li>或者消息过期+死信队列；</li><li>或者延迟队列插件。</li></ul><p><strong>10.哪些情况会导致消息丢失？怎么解决？哪些情况会导致消息重复？怎么解决？</strong></p><p><strong>11. 一个队列最多可以存放多少条消息？</strong></p><p>由硬件决定。</p><p><strong>12.可以用队列的x-max-length最大消息数来实现限流吗？例如秒杀场景。</strong></p><p>不能，因为会删除先入队的消息，不公平。</p><p><strong>13.如何提高消息的消费速率？</strong></p><p>创建多个消费者。</p><p><strong>14.AmqpTemplate和RabbitTemplate的区别？</strong></p><p>Spring AMQP是Spring整合AMQP的一个抽象。Spring-Rabbit是一个实现</p><p><strong>15.如何动态地创建消费者监听队列？</strong></p><p>通过ListenerContainer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container.setQueues(getSecondQueue(),getThirdQueue());<span class="comment">//监听的队列</span></span><br></pre></td></tr></table></figure><p><strong>16.Spring AMQP中消息怎么封装？用什么转换？</strong></p><p>Message，MessageConvertor</p><p><strong>17. 如何保证消息的顺序性？</strong></p><p>一个队列只有一个消费者</p><h2 id="三-RabbitMQ集群相关问题"><a href="#三-RabbitMQ集群相关问题" class="headerlink" title="三.RabbitMQ集群相关问题"></a>三.RabbitMQ集群相关问题</h2><blockquote><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/weixin_43935927/article/details/109741937" target="_blank" rel="noopener">【RabbitMQ】高级使用：集群及haproxy+keepalived高可用负载均衡</a></li></ul></blockquote><p><strong>18.如何保证RabbitMQ的高可用？</strong></p><p>HAProxy（LVS）+Keepalived</p><p><strong>19. RabbitMQ的集群节点类型？</strong></p><p>磁盘节点和内存节点</p><p><strong>20.大量消息堆积怎么办？</strong></p><ul><li><p>重启（不是开玩笑的）</p></li><li><p>多创建几个消费者同时消费</p></li><li><p>直接清空队列，重发消息</p></li></ul><h2 id="四-消息队列开放问题"><a href="#四-消息队列开放问题" class="headerlink" title="四.消息队列开放问题"></a>四.消息队列开放问题</h2><blockquote><p>参考链接：</p><ul><li><a href="https://blog.csdn.net/weixin_43935927/article/details/109661259" target="_blank" rel="noopener">【消息队列】五个问题详解消息中间件</a></li><li><a href="https://blog.csdn.net/weixin_43935927/article/details/109691566" target="_blank" rel="noopener">【Kafka】是什么？应用场景？架构？</a></li><li><a href="https://blog.csdn.net/weixin_43935927/article/details/109712002" target="_blank" rel="noopener">【RabbitMQ】基本特性、工作模型、路由方式</a></li></ul></blockquote><p><strong>21.MQ选型分析？</strong></p><ol><li>使用和管理<ul><li>API、与Spring集成</li><li>管理控制台，权限、安全、监控</li><li>扩展性</li><li>社区支持</li></ul></li><li>性能<ul><li>并发性</li><li>消息吞吐量</li><li>消息堆积能力，即堆积多少消息后，仍然能正常提供服务</li></ul></li><li>功能<ul><li>事务性消息</li><li>顺序性消息</li><li>消息重试</li><li>死信队列</li><li>优先级队列</li><li>延迟队列</li></ul></li><li>可靠+可用<ul><li>集群</li><li>持久化</li><li>消息同步</li></ul></li></ol><p><strong>22.设计一个MQ，你的思路是什么？</strong></p><p>MQ实际上就是做了一个存储并转发的工作</p><ul><li><p>存储</p><ul><li>内存：用什么数据结构？</li><li>磁盘：文件系统？数据库？</li></ul></li><li><p>转发（通信）</p><ul><li>通信协议（TCP HTTP AMQP ）？</li><li>一对一？一对多？</li><li>推模式？拉模式？</li></ul></li><li><p>其他特性……</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-RabbitMQ基本使用问题&quot;&gt;&lt;a href=&quot;#一-RabbitMQ基本使用问题&quot; class=&quot;headerlink&quot; title=&quot;一.RabbitMQ基本使用问题&quot;&gt;&lt;/a&gt;一.RabbitMQ基本使用问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43935927/article/details/109661259&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【消息队列】五个问题详解消息中间件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_43935927/article/details/109712002&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【RabbitMQ】基本特性、工作模型、路由方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.消息队列的作用与使用场景？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异步、解耦、削峰 + 具体应用场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.Channel和vhost的作用是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channel：减少TCP资源的消耗。也是最重要的编程接口。&lt;/li&gt;
&lt;li&gt;Vhost：提高硬件资源利用率，实现资源隔离。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3.RabbitMQ的消息有哪些路由方式？适合在什么业务场景使用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Direct、Topic、Fanout&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.交换机与队列、队列与消费者的绑定关系是什么样的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多对多&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RabbitMQ】高级使用：集群及haproxy+keepalived高可用负载均衡</title>
    <link href="https://yzhblog.work/posts/af1a361b.html"/>
    <id>https://yzhblog.work/posts/af1a361b.html</id>
    <published>2020-08-17T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.940Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为什么要做集群？集群主要用于实现高可用与负载均衡。</p><ul><li>高可用：如果集群中的某些MQ服务器不可用，客户端还可以连接到其他MQ服务器。</li><li>负载均衡：在高并发的场景下，单台MQ服务器能处理的消息有限，可以分发给多台MQ服务器。</li></ul></blockquote><p>RabbitMQ有两种集群模式：普通集群模式和镜像队列模式。</p><h2 id="1-RabbitMQ-如何支持集群"><a href="#1-RabbitMQ-如何支持集群" class="headerlink" title="1.RabbitMQ 如何支持集群"></a>1.RabbitMQ 如何支持集群</h2><p>应用做集群，需要面对数据同步和通信的问题。因为Erlang天生具备分布式的特性，所以RabbitMQ天然支持集群，不需要通过引入ZK或者数据库来实现数据同步</p><p>RabbitMQ通过/var/lib/rabbitmq/.erlang.cookie来验证身份，需要在所有节点上保持一致。</p><p>集群通过25672端口两两通信，需要开放防火墙的端口。需要注意的是，RabbitMQ 集群无法搭建在广域网上，除非使用 federation 或者shovel等插件（没这个必要，在同一个机房做集群）。</p><a id="more"></a><p>集群的配置步骤：</p><ol><li>配置hosts</li><li>同步erlang.cookie</li><li>加入集群（join cluster）</li></ol><h2 id="2-RabbitMQ-集群节点类型"><a href="#2-RabbitMQ-集群节点类型" class="headerlink" title="2.RabbitMQ 集群节点类型"></a>2.RabbitMQ 集群节点类型</h2><p>集群有两种节点类型，一种是磁盘节点（Disc Node），一种是内存节点（RAMNode）</p><h3 id="2-1-磁盘节点"><a href="#2-1-磁盘节点" class="headerlink" title="2.1 磁盘节点"></a>2.1 磁盘节点</h3><p>磁盘节点：将元数据（包括队列名字属性、交换机的类型名字属性、绑定、vhost）放在磁盘中</p><h3 id="2-2-内存节点"><a href="#2-2-内存节点" class="headerlink" title="2.2 内存节点"></a>2.2 内存节点</h3><p>内存节点：将元数据放在内存中。</p><blockquote><p>PS：内存节点会将磁盘节点的地址存放在磁盘（不然重启后就没有办法同步数据了）。如果是持久化的消息，会同时存放在内存和磁盘。集群中至少需要一个磁盘节点用来持久化元数据，否则全部内存节点崩溃时，就无从同步元数据。未指定类型的情况下，默认为磁盘节点。我们一般把应用连接到内存节点（读写快），磁盘节点用来备份。</p></blockquote><h2 id="3-RabbitMQ-集群模式"><a href="#3-RabbitMQ-集群模式" class="headerlink" title="3.RabbitMQ 集群模式"></a>3.RabbitMQ 集群模式</h2><h3 id="3-1-普通集群"><a href="#3-1-普通集群" class="headerlink" title="3.1 普通集群"></a>3.1 普通集群</h3><p>普通集群模式下，不同的节点之间只会相互同步元数据，不同步具体的消息，若需要具体消息时需要转发到源节点(1)</p><p><img src="https://img-blog.csdnimg.cn/20201117231057748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>为什么不直接把队列的内容（消息）在所有节点上复制一份？<br>主要是出于存储和同步数据的网络开销的考虑，如果所有节点都存储相同的数据，就无法达到线性地增加性能和存储容量的目的（堆机器）。</p><ul><li>假如生产者连接的是节点3，要将消息通过交换机A路由到队列1，最终消息还是会转发到节点1上存储，因为队列1的内容只在节点1上。</li><li>同理，如果消费者连接是节点 2，要从队列 1上拉取消息，消息会从节点1 转发到节点2。其它节点起到一个路由的作用，类似于指针。</li></ul><p>普通集群模式不能保证队列的高可用性，因为队列内容不会复制。如果节点失效将导致相关队列不可用，因此我们需要第二种集群模式。</p><h3 id="3-2-镜像集群"><a href="#3-2-镜像集群" class="headerlink" title="3.2 镜像集群"></a>3.2 镜像集群</h3><p>第二种集群模式叫做镜像队列。</p><p>镜像队列模式下，消息内容会在镜像节点间同步，可用性更高。不过也有一定的副作用，系统性能会降低，节点过多的情况下同步的代价比较大。</p><table><thead><tr><th style="text-align:left">操作方式</th><th style="text-align:left">命令或步骤</th></tr></thead><tbody><tr><td style="text-align:left">rabbitmqctl (Windows)</td><td style="text-align:left">rabbitmqctl set_policy ha-all “^ha.” “{“”ha-mode””:””all””}”</td></tr><tr><td style="text-align:left">HTTP API</td><td style="text-align:left">PUT /api/policies/%2f/ha-all {“pattern”:”^ha.”, “definition”:{“ha-mode”:”all”}}</td></tr><tr><td style="text-align:left">WebUI</td><td style="text-align:left">1、 avigate to Admin &gt; Policies &gt; Add / update a policy <br>2、 Name 输入：mirror_image<br> 3、 Pattern输入：^ (代表匹配所有） <br>4、 Definition 点击 HA mode，右边输入：all <br>5、 Add policy</td></tr></tbody></table><h2 id="4-负载均衡-高可用"><a href="#4-负载均衡-高可用" class="headerlink" title="4.负载均衡 + 高可用"></a>4.负载均衡 + 高可用</h2><h3 id="4-1-基于负载均衡组件"><a href="#4-1-基于负载均衡组件" class="headerlink" title="4.1 基于负载均衡组件"></a>4.1 基于负载均衡组件</h3><p>集群搭建成功后，如果有多个内存节点，那么生产者和消费者应该连接到哪个内存节点？如果在我们的代码中根据一定的策略来选择要使用的服务器，那每个地方都要修改，客户端的代码就会出现很多的重复，修改起来也比较麻烦。</p><p><img src="https://img-blog.csdnimg.cn/20201117231923657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>所以需要一个负载均衡的组件（例如HAProxy，LVS，Nignx），由负载的组件来做路由。这个时候，只需要连接到负载组件的IP地址就可以了。负载分为四层负载和七层负载。</p><blockquote><ul><li>四层负载：工作在OSI模型的第四层，即传输层（TCP位于第四层），它是根据IP端口进行转发（LVS支持四层负载）。RabbitMQ是TCP的5672端口。</li><li>七层负载：工作在第七层，应用层（HTTP位于第七层）。可以根据请求资源类型分配到后端服务器（Nginx支持七层负载；HAProxy支持四层和七层负载）。 </li></ul></blockquote><p><img src="https://img-blog.csdnimg.cn/20201117232139301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>但是，如果这个负载的组件也挂了呢？客户端就无法连接到任意一台MQ的服务器了。所以负载软件本身也需要做一个集群。新的问题又来了，如果有两台负载的软件，客户端应该连哪个？</p><p><img src="https://img-blog.csdnimg.cn/2020111723224438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>负载之上再负载？陷入死循环了。这个时候我们就要换个思路了。我们应该需要这样一个组件：</p><ol><li>它本身有路由（负载）功能，可以监控集群中节点的状态（比如监控HAProxy），如果某个节点出现异常或者发生故障，就把它剔除掉。</li><li>为了提高可用性，它也可以部署多个服务，但是只有一个自动选举出来的MASTER服务器（叫做主路由器），通过广播心跳消息实现。</li><li>MASTER 服务器对外提供一个虚拟 IP，提供各种网络功能。也就是谁抢占到VIP，就由谁对外提供网络服务。应用端只需要连接到这一个IP就行了。</li></ol><p>这个协议叫做 VRRP 协议（虚拟路由冗余协议 Virtual Router RedundancyProtocol），这个组件就是Keepalived，它具有负载均衡（LoadBalance）和高可用（HighAvailability）的功能。</p><h3 id="4-2-HAproxy-负载-Keepalived-高可用"><a href="#4-2-HAproxy-负载-Keepalived-高可用" class="headerlink" title="4.2 HAproxy 负载+Keepalived 高可用"></a>4.2 HAproxy 负载+Keepalived 高可用</h3><p>基于 Docker 安装 HAproxy 负载+Keepalived 高可用</p><img src="https://img-blog.csdnimg.cn/20201117233711782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"><p>IP规划：</p><ul><li>内存节点1：192.168.8.40</li><li>内存节点2：192.168.8.45</li><li>磁盘节点：192.168.8.150</li><li>VIP：192.168.8.220</li></ul><p>具体搭建步骤：</p><ol><li>我们规划了两个内存节点，一个磁盘节点。所有的节点之间通过镜像队列的方式同步数据。内存节点用来给应用访问，磁盘节点用来持久化数据。</li><li>为了实现对两个内存节点的负载， 我们安装了两个HAProxy，监听两个5672和15672的端口。</li><li>安装两个Keepalived，一主一备。两个Keepalived抢占一个VIP192.168.8.220。谁抢占到这个VIP，应用就连接到谁，来执行对MQ的负载。</li></ol><p>这种情况下，我们的Keepalived挂了一个节点，没有影响，因为BACKUP会变成 MASTER，抢占 VIP。HAProxy挂了一个节点，没有影响，我们的 VIP 会自动路由的可用的HAProxy服务。RabbitMQ挂了一个节点，没有影响， 因为 HAProxy 会自动负载到可用的节点。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;为什么要做集群？集群主要用于实现高可用与负载均衡。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高可用：如果集群中的某些MQ服务器不可用，客户端还可以连接到其他MQ服务器。&lt;/li&gt;
&lt;li&gt;负载均衡：在高并发的场景下，单台MQ服务器能处理的消息有限，可以分发给多台MQ服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;RabbitMQ有两种集群模式：普通集群模式和镜像队列模式。&lt;/p&gt;
&lt;h2 id=&quot;1-RabbitMQ-如何支持集群&quot;&gt;&lt;a href=&quot;#1-RabbitMQ-如何支持集群&quot; class=&quot;headerlink&quot; title=&quot;1.RabbitMQ 如何支持集群&quot;&gt;&lt;/a&gt;1.RabbitMQ 如何支持集群&lt;/h2&gt;&lt;p&gt;应用做集群，需要面对数据同步和通信的问题。因为Erlang天生具备分布式的特性，所以RabbitMQ天然支持集群，不需要通过引入ZK或者数据库来实现数据同步&lt;/p&gt;
&lt;p&gt;RabbitMQ通过/var/lib/rabbitmq/.erlang.cookie来验证身份，需要在所有节点上保持一致。&lt;/p&gt;
&lt;p&gt;集群通过25672端口两两通信，需要开放防火墙的端口。需要注意的是，RabbitMQ 集群无法搭建在广域网上，除非使用 federation 或者shovel等插件（没这个必要，在同一个机房做集群）。&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RabbitMQ】高级使用：补偿机制、消息幂等性、最终一致性、消息顺序性</title>
    <link href="https://yzhblog.work/posts/45d5320f.html"/>
    <id>https://yzhblog.work/posts/45d5320f.html</id>
    <published>2020-08-15T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-补偿机制"><a href="#1-补偿机制" class="headerlink" title="1.补偿机制"></a>1.补偿机制</h2><p>由于生产者与消费者完全隔离，即使消费者没有接收到消息，或者消费时出现异常，生产者也是完全不知情的。所以生产者最终确定消费者有没有消费成功有两种<strong>通信</strong>方式：</p><ol><li><p>消费者收到消息，处理完毕后，调用生产者的API</p><p>例如：提单系统给其他系统发送了碎屏保消息后，其他系统必须在处理完消息后调用提单系统提供的API，来修改提单系统中数据的状态。只要API没有被调用，数据状态没有被修改，提单系统就认为下游系统没有收到这条消息。</p></li><li><p>消费者收到消息，处理完毕后，发送一条响应消息给生产者</p><p>例如：商业银行与人民银行二代支付通信，无论是人行收到了商业银行的消息，还是商业银行收到了人行的消息，都必须发送一条响应消息（叫做回执报文）。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/2020111718512878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>无论采用哪种回调方式，如果生产者的API就是没有被调用，也没有收到消费者的响应消息，怎么办？可能是消费者处理时间太长或者网络超时。</p><a id="more"></a><p>生产者与消费者之间应该约定一个超时时间，比如5分钟，对于超出这个时间没有得到响应的消息，可以设置一个定时重发的机制</p><ul><li><p>重发可以通过消息落库+定时任务来实现</p></li><li><p>要控制发送间隔和次数，比如每隔2分钟发送一次，最多重发3次，否则会造成消息堆积</p></li><li><p>重发的消息，随具体场景的变化而变化，不能在Producer写死                                                               </p><p>参考：ATM机上运行的系统叫C端（ATMC）。前置系统叫P端（ATMC），它接收ATMC的消息，再转发给卡系统或者核心系统。</p><ul><li>如果客户存款，没有收到核心系统的应答，不知道有没有记账成功，最多发送5次<strong>存款确认报文</strong>，因为已经吞钞了，所以要保证成功； </li><li>如果客户取款，ATMC未得到应答时，最多发送5次<strong>存款冲正报文</strong>。因为没有吐钞，所以要保证失败。</li></ul></li></ul><h2 id="2-消息幂等性"><a href="#2-消息幂等性" class="headerlink" title="2.消息幂等性"></a>2.消息幂等性</h2><p>如果消费者每一次接收生产者的消息都成功了，只是在响应或者调用API的时候出了问题，会不会出现消息的重复处理？例如：存款100元，ATM重发了5次，核心系统一共处理了6次，余额增加了600元。</p><p>所以幂等性简单来说就是：重复调用多次产生的业务结果与调用一次产生的业务结果相同； </p><p>为了避免相同消息的重复处理，必须要采取一定的措施。RabbitMQ服务端是没有这种控制的（同一批的消息有个递增的DeliveryTag），它不知道你是不是就要把一条消息发送两次，只能在消费端控制。</p><p>如何避免消息的重复消费？消息出现重复可能会有两个原因：</p><ol><li>生产者问题，环节①重复发送消息，比如在开启了Confirm模式但未收到确认，生产者重新发送消息</li><li>消费者问题，环节④出了问题，由于消费者未发送ACK或者其他原因，消息重复投递</li></ol><p>对于重复发送的消息，可以对每一条消息生成一个唯一的业务ID，通过日志或者消息落库来做重复控制。</p><h2 id="3-最终一致性"><a href="#3-最终一致性" class="headerlink" title="3.最终一致性"></a>3.最终一致性</h2><p>如果确实是消费者宕机了，或者代码出现了BUG导致无法正常消费，在我们尝试多次重发以后，消息最终也没有得到处理，怎么办？</p><p>例如存款的场景，客户的钱已经被吞了，但是余额没有增加，这个时候银行出现了长款，应该怎么处理？如果客户没有主动通知银行，这个问题是怎么发现的？银行最终怎么把这个账务做平？</p><p>在我们的金融系统中，都会有双方对账或者多方对账的操作，通常是在一天的业务结束之后，第二天营业之前。我们会约定一个标准，比如ATM跟核心系统对账，肯定是以核心系统为准。ATMC获取到核心的对账文件，然后解析，登记成数据，然后跟自己记录的流水比较，找出核心有ATM没有，或者ATM有核心没有，或者两边都有但是金额不一致的数据。</p><p>对账之后，我们再手工平账。比如取款记了账但是没吐钞的，做一笔冲正。存款吞了钞没记账的，要么把钱退给客户，要么补一笔账 </p><h2 id="4-消息顺序性"><a href="#4-消息顺序性" class="headerlink" title="4.消息顺序性"></a>4.消息顺序性</h2><p>消息的顺序性指的是消费者消费消息的顺序跟生产者生产消息的顺序是一致的。示例如下</p><ul><li>商户信息同步到其他系统，有三个业务操作：1、新增门店 2、绑定产品 3、激活门店，这种情况下消息消费顺序不能颠倒（门店不存在时无法绑定产品和激活）。</li><li>1、发表微博；2、发表评论；3、删除微博。顺序不能颠倒。</li></ul><p>在RabbitMQ中，一个队列有多个消费者时，由于不同的消费者消费消息的速度是不一样的，顺序无法保证。只有一个队列<strong>仅有一个消费者</strong>的情况才能保证顺序消费（不同的业务消息发送到不同的专用的队列）。</p><p><img src="https://img-blog.csdnimg.cn/20201117185356581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>==&gt; 除非负载的场景，一个队列不要用多个消费者消费消息。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-补偿机制&quot;&gt;&lt;a href=&quot;#1-补偿机制&quot; class=&quot;headerlink&quot; title=&quot;1.补偿机制&quot;&gt;&lt;/a&gt;1.补偿机制&lt;/h2&gt;&lt;p&gt;由于生产者与消费者完全隔离，即使消费者没有接收到消息，或者消费时出现异常，生产者也是完全不知情的。所以生产者最终确定消费者有没有消费成功有两种&lt;strong&gt;通信&lt;/strong&gt;方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;消费者收到消息，处理完毕后，调用生产者的API&lt;/p&gt;
&lt;p&gt;例如：提单系统给其他系统发送了碎屏保消息后，其他系统必须在处理完消息后调用提单系统提供的API，来修改提单系统中数据的状态。只要API没有被调用，数据状态没有被修改，提单系统就认为下游系统没有收到这条消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消费者收到消息，处理完毕后，发送一条响应消息给生产者&lt;/p&gt;
&lt;p&gt;例如：商业银行与人民银行二代支付通信，无论是人行收到了商业银行的消息，还是商业银行收到了人行的消息，都必须发送一条响应消息（叫做回执报文）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020111718512878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;无论采用哪种回调方式，如果生产者的API就是没有被调用，也没有收到消费者的响应消息，怎么办？可能是消费者处理时间太长或者网络超时。&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RabbitMQ】高级使用：实际开发中的几点建议</title>
    <link href="https://yzhblog.work/posts/4894b756.html"/>
    <id>https://yzhblog.work/posts/4894b756.html</id>
    <published>2020-08-15T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-资源管理"><a href="#1-资源管理" class="headerlink" title="1.资源管理"></a>1.资源管理</h2><ul><li>在实际生产中，交换机和队列实际上是作为资源（跑起来才有的），由运维管理员提前创建的。是要申请的</li><li>但写代码时，还要声明（new）相应的Exchange、Queue、绑定<ul><li>为了保证所到Exchange，Queue一定存在</li><li>若已经被创建好的Exchange，Queue再在代码new时，直接返回true，不报错</li></ul></li><li>Exchange，Queue 一般是在消费者的代码中定义<ul><li>谁使用是管理原则，所以一般在消费者创建</li><li>同时还因为消费者启动就会开始监听队列，并且长时间在线</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20201117234316653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" width="80%"></p><a id="more"></a><h2 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2.命名规范"></a>2.命名规范</h2><ol><li><p>命名体现元数据的类型</p><ul><li>虚拟机命名： XXX_VHOST</li><li>交换机命名：XXX_EXCHANGE</li><li>队列命名：_QUEUE</li></ul></li><li><p>命名体现数据来源和去向</p><p>示例：销售系统发往产品系统的交换机：SALE_TO_PRODUCT_EXCHANGE。做到见名知义，不用去查文档（当然注释是必不可少的）</p></li></ol><h2 id="3-配置文件-声明"><a href="#3-配置文件-声明" class="headerlink" title="3.配置文件+声明"></a>3.配置文件+声明</h2><ul><li>元数据的命名集中放在 properties 文件中，不要用硬编码。</li><li>如果有多个系统，可以配置多个xxx_mq.properties。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># mq.properties</span><br><span class="line">com.my.directexchange=MY_DIRECT_EXCHANGE</span><br><span class="line">com.my.topicexchange=MY_TOPIC_EXCHANGE</span><br><span class="line">com.my.fanoutexchange=MY_FANOUT_EXCHANGE</span><br><span class="line">com.my.firstqueue=MY_FIRST_QUEUE</span><br><span class="line">com.my.secondqueue=MY_SECOND_QUEUE</span><br><span class="line">com.my.thirdqueue=MY_THIRD_QUEUE</span><br><span class="line">com.my.fourthqueue=MY_FOURTH_QUEUE</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:mq.properties"</span>) <span class="comment">// 读取properties文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;com.my.firstqueue&#125;"</span>)  <span class="comment">// 获取队列名</span></span><br><span class="line">    <span class="keyword">private</span> String firstQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;com.my.directexchange&#125;"</span>) <span class="comment">// 获取交换机名</span></span><br><span class="line">    <span class="keyword">private</span> String directExchange;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"myFirstQueue"</span>)  <span class="comment">// 声明队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">getFirstQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(firstQueue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"myDirectExchange"</span>) <span class="comment">// 声明交换机</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">getDirectExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(directExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindFirst</span><span class="params">(@Qualifier(<span class="string">"myFirstQueue"</span>)</span> Queue queue, <span class="comment">// 声明绑定</span></span></span><br><span class="line"><span class="function">                             @<span class="title">Qualifier</span><span class="params">(<span class="string">"myDirectExchange"</span>)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">"my.best"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-再次封装"><a href="#4-再次封装" class="headerlink" title="4.再次封装"></a>4.再次封装</h2><ul><li><p>在项目中可以对Template做进一步封装，简化消息的发送</p><p>例如：如果交换机、路由键是固定的，封装之后就只需要一个参数：消息内容。</p></li><li><p>另外，如果想要平滑地迁移不同的MQ（如果有这种需求的话），也可以再做一层简单的封装</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sendMsg()&#123;</span><br><span class="line">JmsTemplate.send(destination,msg); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这时，如果要把ActiveMQ替换为RabbitMQ，还是使用send方法，只用更改调用对象</span></span><br><span class="line">sendMsg()&#123;</span><br><span class="line">RabbitTemplate.send(exchange,routingKey,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-信息落库-定时任务"><a href="#5-信息落库-定时任务" class="headerlink" title="5.信息落库+定时任务"></a>5.信息落库+定时任务</h2><p>将需要发送的消息保存在数据库中，可以实现消息的可追溯和重复控制，需要配合定时任务来实现。</p><ol><li>将需要发送的消息登记在消息表中</li><li>定时任务一分钟或半分钟扫描一次，将未发送的消息发送到MQ服务器，并且修改状态为已发送</li><li>如果需要重发消息，将指定消息的状态修改为未发送即可</li></ol><p>副作用：降低效率，浪费存储空间</p><h2 id="6-生产环境运维监控"><a href="#6-生产环境运维监控" class="headerlink" title="6.生产环境运维监控"></a>6.生产环境运维监控</h2><p>虽然RabbitMQ提供了一个简单的管理界面，但是如果对于系统性能、高可用和其他参数有一些定制化的监控需求的话，我们就需要通过其他方式来实现监控了。</p><p>主要关注：磁盘、内存、连接数</p><p><img src="https://img-blog.csdnimg.cn/20201117234526956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201117234549512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="7-日志追踪"><a href="#7-日志追踪" class="headerlink" title="7.日志追踪"></a>7.日志追踪</h2><p>RabbitMQ可以通过<a href="https://www.rabbitmq.com/firehose.html" target="_blank" rel="noopener">Firehose</a>功能来记录消息流入流出的情况，用于调试，排错。</p><ul><li>它是通过创建一个TOPIC类型的交换机（amq.rabbitmq.trace），把生产者发送给Broker的消息或者Broker发送给消费者的消息发到这个默认的交换机上面来实现的。</li><li>另外RabbitMQ也提供了一个Firehose的GUI版本，就是Tracing插件。启用Tracing插件后管理界面右侧选项卡会多一个Tracing，可以添加相应的策略。</li><li>RabbitMQ还提供了其他的<a href="https://www.rabbitmq.com/plugins.html" target="_blank" rel="noopener">插件</a>来增强功能。</li></ul><h2 id="如何减少连接数？"><a href="#如何减少连接数？" class="headerlink" title="如何减少连接数？"></a>如何减少连接数？</h2><p>在发送大批量消息的情况下，创建和释放连接依然有不小的开销。我们可以跟接收方约定<strong>批量消息的格式</strong>，比如支持JSON数组的格式，通过<strong>合并消息内容</strong>，可以减少生产者/消费者与Broker的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Producer将MQ消息分成10个一条记录，并批量记录数据库</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partAndInsertMq</span><span class="params">(List&lt;StoreProdToAlsBean&gt; list, String dType)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 通过getAverRange方法，将没每10条数据合并成一组，表示1条消息</span></span><br><span class="line"><span class="comment">// 所以，最后会有n个条消息（每条消息里面10条数据），再批量发送</span></span><br><span class="line">List&lt;List&lt;StoreProdToAlsBean&gt;&gt; partLists = getAverRange(list,<span class="number">10</span>);</span><br><span class="line">List&lt;MQTask&gt; mqList = <span class="keyword">new</span> ArrayList&lt;MQTask&gt;();</span><br><span class="line"><span class="keyword">for</span>( List&lt;SimsStoreProdToAlsBean&gt; partList: partLists )&#123;</span><br><span class="line"></span><br><span class="line">MQTask mqMsg = <span class="keyword">new</span> MQTask();</span><br><span class="line">mqMsg.setRoutingKey(Constant.MQRoutingKeys.MQ_CXF.getRoutingKey());</span><br><span class="line"></span><br><span class="line">JSONObject pdDelDson = <span class="keyword">new</span> JS0N0bject();</span><br><span class="line">pdDelDson.put(<span class="string">"data"</span>, JSONArray.fromObject(partList));</span><br><span class="line">pdDelDson.put(<span class="string">"title"</span>, <span class="string">"storeProd"</span>);</span><br><span class="line">pdDelDson.put(<span class="string">"dType"</span>, dType);</span><br><span class="line">mqMsg.setJsonDatastr(pdDelJson.toString〇);</span><br><span class="line"></span><br><span class="line">Long regDay = Long.porselong(DatesUtil.dateToString(<span class="keyword">new</span> Date(), DatesUtil.SIMPLE_TIME));</span><br><span class="line">mqMsg.setRegDay(regDay);</span><br><span class="line">mqMsg.setLastUpTms(regDay);</span><br><span class="line">mqMsg.setMqStatus(<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">mqList.add(mqMsg);</span><br><span class="line">&#125;</span><br><span class="line">NewBatchImportDao.batachInsertMQTask(mqlist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把一个数组没份N个划分，返回一个最大的数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Param</span> list 数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Param</span> average 每份包含多少个</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Return</span> 新的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;List&lt;T&gt;&gt; getAverRange( List&lt;T&gt; list, <span class="keyword">int</span> average )&#123; </span><br><span class="line">List&lt;List&lt;T&gt;&gt; newArrays = <span class="keyword">new</span> ArrayList&lt;List&lt;T&gt;&gt;(); </span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= list.size() / average; i++) &#123;</span><br><span class="line">List&lt;T&gt; partList = <span class="keyword">new</span> ArrayList&lt;T&gt;(); </span><br><span class="line">end = start + average; </span><br><span class="line"><span class="keyword">if</span> (start &gt;= list.size〇) &#123; </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (end &gt;= list.size()) &#123; </span><br><span class="line">end = list.size();</span><br><span class="line">&#125;</span><br><span class="line">partList = list.subList(start, end); </span><br><span class="line">newArrays.add(partList); </span><br><span class="line">start = end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArrays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等发送到Broker后，每条消息的格式如下，在数据部分是一个数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">msgContent = &#123; </span><br><span class="line">    <span class="string">"title"</span>:<span class="string">"storeProd"</span>, </span><br><span class="line">    <span class="string">"dType"</span>:“add”, </span><br><span class="line">    <span class="string">"data"</span>:[ </span><br><span class="line">        &#123;<span class="string">"merchName"</span>:<span class="string">"黄金手机店"</span>,<span class="string">"address"</span>:<span class="string">"黄金路 999 号"</span>&#125;, </span><br><span class="line">        &#123;<span class="string">"merchName"</span>:<span class="string">"银星手机店"</span>,<span class="string">"address"</span>:<span class="string">"银星路 168 号"</span>&#125;, </span><br><span class="line">        &#123;<span class="string">"merchName"</span>:<span class="string">"青山手机店"</span>,<span class="string">"address"</span>:<span class="string">"青山路 73 号"</span>&#125; </span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>建议单条消息不要超过4M（4096KB），一次发送的消息数需要合理地控制。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-资源管理&quot;&gt;&lt;a href=&quot;#1-资源管理&quot; class=&quot;headerlink&quot; title=&quot;1.资源管理&quot;&gt;&lt;/a&gt;1.资源管理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在实际生产中，交换机和队列实际上是作为资源（跑起来才有的），由运维管理员提前创建的。是要申请的&lt;/li&gt;
&lt;li&gt;但写代码时，还要声明（new）相应的Exchange、Queue、绑定&lt;ul&gt;
&lt;li&gt;为了保证所到Exchange，Queue一定存在&lt;/li&gt;
&lt;li&gt;若已经被创建好的Exchange，Queue再在代码new时，直接返回true，不报错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Exchange，Queue 一般是在消费者的代码中定义&lt;ul&gt;
&lt;li&gt;谁使用是管理原则，所以一般在消费者创建&lt;/li&gt;
&lt;li&gt;同时还因为消费者启动就会开始监听队列，并且长时间在线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201117234316653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RabbitMQ】原理分析：如何保证消息可靠性投递？</title>
    <link href="https://yzhblog.work/posts/27663eac.html"/>
    <id>https://yzhblog.work/posts/27663eac.html</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.972Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ的可靠性投递，也就是在使用RabbitMQ实现异步通信的时候，消息丢了怎么办，消息重复消费怎么办？在RabbitMQ里面提供了很多保证消息可靠投递的机制，这个也是RabbitMQ的一个特性。</p><p>在说可靠性投递的时候，必须要明确一个问题，因为效率与可靠性是无法兼得的，如果要保证每一个环节都成功，势必会对消息的收发效率造成影响。所以如果是一些业务实时一致性要求不是特别高的场合，可以牺牲一些可靠性来换取效率。比如发送通知或者记录日志的这种场景，如果用户没有收到通知，不会造成业务影响，只要再次发送就可以了。</p><p>下图是RabbitMQ的工作模型，其中标出的是需要保证消息可靠性的地方</p><p><img src="https://img-blog.csdnimg.cn/2020111714475088.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ol><li><p>消息从生产者发送到Broker</p><p>生产者把消息发到Broker之后，怎么知道自己的消息有没有被Broker成功接收？</p></li><li><p>消息从Exchange路由到Queue</p><p>Exchange是一个绑定列表，如果消息没有办法路由到正确的队列，会发生什么事情？应该怎么处理？</p></li><li><p>消息在Queue中存储</p><p>队列是一个独立运行的服务，有自己的数据库（Mnesia），它是真正用来存储消息的。如果还没有消费者来消费，那么消息要一直存储在队列里面。如果队列出了问题，消息肯定会丢失。怎么保证消息在队列稳定地存储呢？</p></li><li><p>消费者订阅Queue并消费消息</p><p>队列的特性是什么？FIFO。队列里面的消息是一条一条的投递的，也就是说，只有上一条消息被消费者接收以后，才能把这一条消息从数据库删掉，继续投递下一条消息。那么问题来了，Broker怎么知道消费者已经接收了消息呢？</p></li></ol><p>下面，我们就从这四个方面来看，RabbitMQ是如何保证消息可靠性的。</p><a id="more"></a><h2 id="1-Producer–-gt-Broker"><a href="#1-Producer–-gt-Broker" class="headerlink" title="1.Producer–&gt;Broker"></a>1.Producer–&gt;Broker</h2><p>第一个环节是生产者发送消息到Broker。可能因为网络或者Broker的问题导致消息发送失败，生产者不能确定Broker有没有正确的接收。 在 RabbitMQ 里面提供了两种机制服务端确认机制，也就是在生产者发送消息给RabbitMQ的服务端的时候，服务端会通过某种方式返回一个应答，只要生产者收到了这个应答，就知道消息发送成功了。</p><p>第一种是Transaction（事务）模式，第二种Confirm（确认）模式。</p><h3 id="1-1-事务模式ACK"><a href="#1-1-事务模式ACK" class="headerlink" title="1.1 事务模式ACK"></a>1.1 事务模式ACK</h3><p>通过<code>channel.txSelect()</code>方法把信道设置成事务模式，然后就可以发布消息给RabbitMQ了</p><ul><li>若<code>channel.txCommit()</code>的方法调用成功，就说明事务提交成功，则消息一定到达了RabbitMQ中。</li><li>如果在事务提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这个时候便可以将其捕获，进而通过执行<code>channel.txRollback()</code>方法来实现事务回滚。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123; <span class="comment">// 原生API</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"ORIGIN_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUri(ResourceUtil.getKey(<span class="string">"rabbitmq.uri"</span>));</span><br><span class="line">       </span><br><span class="line">        Connection conn = factory.newConnection(); <span class="comment">// 建立连接        </span></span><br><span class="line">        Channel channel = conn.createChannel(); <span class="comment">// 创建消息通道</span></span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">"Hello world, Rabbit MQ"</span>;</span><br><span class="line">        <span class="comment">// 声明队列（默认交换机AMQP default，Direct）</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.txSelect(); <span class="comment">// 事务模式</span></span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="comment">// String exchange, String routingKey, BasicProperties props, byte[] body</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, (msg).getBytes());</span><br><span class="line">            <span class="comment">// int i =1/0;</span></span><br><span class="line">            channel.txCommit(); <span class="comment">// 提交，阻塞</span></span><br><span class="line">            System.out.println(<span class="string">"消息发送成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            channel.txRollback(); <span class="comment">// 回滚</span></span><br><span class="line">            System.out.println(<span class="string">"消息已经回滚"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在事务模式里面，只有收到了服务端的 Commit-OK的指令，才能提交成功。所以可以解决生产者和服务端确认的问题。但是事务模式有一个缺点，它是<strong>阻塞的</strong>，一条消息没有发送完毕，不能发送下一条消息，它可能会榨干RabbitMQ服务器的性能。所以不建议在生产环境使用。</p><p>使用SpringAMQP时，在构造RabbitTemplate的Bean时设置，因为RabbitTemplate封装了channel</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">rabbitTemplate.setChannelTransacted(true);</span></span><br></pre></td></tr></table></figure><p>那么有没有其他可以保证消息被Broker接收，但是又不大量消耗性能的方式呢？这个就是第二种模式，叫做确认（Confirm）模式。</p><h3 id="1-2-确认模式ACK"><a href="#1-2-确认模式ACK" class="headerlink" title="1.2 确认模式ACK"></a>1.2 确认模式ACK</h3><p>生产者通过调用 channel 的 confirmSelect 方法将 channel 设置为 confirm 模式。该模式下，所有在该信道上发布的消息都会被分派一个唯一的ID(从1开始)，当消息被投递到所有匹配的队列后，broker 就会发送一个(包含消息的唯一 ID 的)确认给发送端，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条nack消息，发送端的 Confirm Listener 会去监听应答。</p><blockquote><p>broker回传给发送端的确认消息中，包含了 deliver-tag （确认消息的ID） 和 此外 basic.ack 的 multiple 域（表示到这个ID之前的所有消息都已经得到了处理）。</p></blockquote><p>确认模式（Confirm）有三种具体实现：</p><p><strong>1.普通确认模式</strong></p><p>在生产者这边通过调用<code>channel.confirmSelect()</code>方法将信道设置为Confirm模式，然后发送消息。一旦消息被投递到所有匹配的队列后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者，也就是调用 <code>channel.waitForConfirms()</code>返回true，这样生产者就知道消息被服务端接收了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalConfirmProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"ORIGIN_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUri(ResourceUtil.getKey(<span class="string">"rabbitmq.uri"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        Connection conn = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建消息通道</span></span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">"Hello world, Rabbit MQ ,Normal Confirm"</span>;</span><br><span class="line">        <span class="comment">// 声明队列（默认交换机AMQP default，Direct）</span></span><br><span class="line">        <span class="comment">// String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启发送方确认模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        <span class="comment">// 普通Confirm，发送一条，确认一条</span></span><br><span class="line">        <span class="keyword">if</span> (channel.waitForConfirms()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"消息发送成功"</span> );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种发送1条确认1条的方式消息还不是太高，所以还有一种批量确认的方式。</p><p><strong>2.批量确认模式</strong></p><p>批量确认就是在开启Confirm模式后，先发送一批消息。只要<code>channel.waitForConfirmsOrDie()</code>方法没有抛出异常，就代表消息都被服务端接收了。</p><p>批量确认的方式比单条确认的方式效率要高，但是对于不同的业务，到底发送多少条消息确认一次？</p><ul><li>数量太少，效率提升不上去。</li><li>数量多的话，又会带来另一个问题，比如我们发1000条消息才确认一次，如果前面999 条消息都被服务端接收了，如果第1000条消息被拒绝了，那么前面所有的消息都要重发。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchConfirmProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"ORIGIN_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUri(ResourceUtil.getKey(<span class="string">"rabbitmq.uri"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        Connection conn = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建消息通道</span></span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">"Hello world, Rabbit MQ ,Batch Confirm"</span>;</span><br><span class="line">        <span class="comment">// 声明队列（默认交换机AMQP default，Direct）</span></span><br><span class="line">        <span class="comment">// String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.confirmSelect();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                <span class="comment">// String exchange, String routingKey, BasicProperties props, byte[] body</span></span><br><span class="line">                channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, (msg +<span class="string">"-"</span>+ i).getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 批量确认结果，ACK如果是Multiple=True，代表ACK里面的Delivery-Tag之前的消息都被确认了</span></span><br><span class="line">            <span class="comment">// 比如5条消息可能只收到1个ACK，也可能收到2个（抓包才看得到）</span></span><br><span class="line">            <span class="comment">// 直到所有信息都发布，只要有一个未被Broker确认就会IOException</span></span><br><span class="line">            channel.waitForConfirmsOrDie();</span><br><span class="line">            System.out.println(<span class="string">"消息发送完毕，批量确认成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 发生异常，可能需要对所有消息进行重发</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有一种方式，可以一边发送一边确认的呢？这个就是异步确认模式</p><p><strong>3.异步确认模式</strong></p><p>异步确认模式需要添加一个 ConfirmListener，并且用一个 SortedSet 来维护没有被确认的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfirmProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"ORIGIN_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUri(ResourceUtil.getKey(<span class="string">"rabbitmq.uri"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        Connection conn = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建消息通道</span></span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">"Hello world, Rabbit MQ, Async Confirm"</span>;</span><br><span class="line">        <span class="comment">// 声明队列（默认交换机AMQP default，Direct）</span></span><br><span class="line">        <span class="comment">// String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来维护未确认消息的deliveryTag</span></span><br><span class="line">        <span class="keyword">final</span> SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet&lt;Long&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里不会打印所有响应的ACK；ACK可能有多个，有可能一次确认多条，也有可能一次确认一条</span></span><br><span class="line">        <span class="comment">// 异步监听确认和未确认的消息</span></span><br><span class="line">        <span class="comment">// 如果要重复运行，先停掉之前的生产者，清空队列</span></span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">        <span class="comment">// 处理未确认的消息</span></span><br><span class="line">    <span class="comment">// deliverTag：交付标签，标识服务端处理到哪条消息了</span></span><br><span class="line">    <span class="comment">// multiple：是否批量处理模式</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Broker未确认消息，标识："</span> + deliveryTag);</span><br><span class="line">                <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                    <span class="comment">// headSet表示后面参数之前的所有元素，全部删除</span></span><br><span class="line">                    confirmSet.headSet(deliveryTag + <span class="number">1L</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里添加重发的方法</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理已确认的消息</span></span><br><span class="line">    <span class="comment">// multiple如果true，表示批量执行了deliveryTag这个值以前（小于deliveryTag的）的所有消息，</span></span><br><span class="line">    <span class="comment">// 如果为false的话表示单条确认</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// 如果true表示批量执行了deliveryTag这个值以前（小于deliveryTag的）的所有消息，如果为false的话表示单条确认</span></span><br><span class="line">                System.out.println(String.format(<span class="string">"Broker已确认消息，标识：%d，多个消息：%b"</span>, deliveryTag, multiple));</span><br><span class="line">                <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                    <span class="comment">// headSet表示后面参数之前的所有元素，全部删除</span></span><br><span class="line">                    confirmSet.headSet(deliveryTag + <span class="number">1L</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 只移除一个元素</span></span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"未确认的消息:"</span>+confirmSet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启发送方确认模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取消息的唯一ID，之后要加入sortedSet</span></span><br><span class="line">            <span class="keyword">long</span> nextSeqNo = channel.getNextPublishSeqNo();</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="comment">// String exchange, String routingKey, BasicProperties props, byte[] body</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, (msg +<span class="string">"-"</span>+ i).getBytes());</span><br><span class="line">            confirmSet.add(nextSeqNo);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"所有消息:"</span>+confirmSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里注释掉的原因是如果先关闭了，可能收不到后面的ACK</span></span><br><span class="line">        <span class="comment">//channel.close();</span></span><br><span class="line">        <span class="comment">//conn.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们上面发送了10条消息，分别运行了两次，得到的结果如下：<img src="https://img-blog.csdnimg.cn/2020111718052370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt><br>可以看到第一遍是异步确认了3次，第二遍运行是异步确认了6次。</p><p>上面演示的是amqp-client原生api，Confirm模式是在Channel上开启的；而Spring AMQP中RabbitTemplate对Channel的Confirm回调进行了封装，叫做ConfimrCallback。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建RabbitTemplate的Bean时配置</span></span><br><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.setChannelTransacted(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当消息成功到达exchange，但是没有队列与之绑定的时候触发的ack回调</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!ack) &#123;</span><br><span class="line">                System.out.println(<span class="string">"发送消息失败："</span> + cause);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"发送异常："</span> + cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Exchange–-gt-Queue"><a href="#2-Exchange–-gt-Queue" class="headerlink" title="2.Exchange–&gt;Queue"></a>2.Exchange–&gt;Queue</h2><p>第二个环节就是消息从交换机路由到队列。在什么情况下，消息会无法路由到正确的队列？可能因为路由键错误，或者队列不存在。有两种方式处理无法路由的消息：</p><ul><li>一种就是让服务端回发给生产者</li><li>一种是让交换机路由到另一个备份的交换机</li></ul><h3 id="2-1-消息回发"><a href="#2-1-消息回发" class="headerlink" title="2.1 消息回发"></a>2.1 消息回发</h3><p>消息回发的方式：使用 mandatory 参数和 ReturnListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnListenerProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    </span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUri(ResourceUtil.getKey(<span class="string">"rabbitmq.uri"</span>));</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加监听</span></span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String routingKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"=========监听器收到了无法路由，被返回的消息============"</span>);</span><br><span class="line">                System.out.println(<span class="string">"replyText:"</span>+replyText);</span><br><span class="line">                System.out.println(<span class="string">"exchange:"</span>+exchange);</span><br><span class="line">                System.out.println(<span class="string">"routingKey:"</span>+routingKey);</span><br><span class="line">                System.out.println(<span class="string">"message:"</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder().deliveryMode(<span class="number">2</span>).</span><br><span class="line">                contentEncoding(<span class="string">"UTF-8"</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送到了默认的交换机上，由于没有任何队列使用这个关键字跟交换机绑定，所以会被退回</span></span><br><span class="line">        <span class="comment">// 第三个参数是设置的mandatory，如果mandatory是false，消息也会被直接丢弃</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,<span class="string">"mydirect"</span>,<span class="keyword">true</span>, properties,<span class="string">"只为更好的你"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SpringAMQP中是ReturnCallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建RabbitTemplate的Bean时配置</span></span><br><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">    </span><br><span class="line">    rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 当消息成功到达exchange，且无法被路由时触发回调，进行消息回发</span></span><br><span class="line">    rabbitTemplate.setReturnCallback(<span class="keyword">new</span> RabbitTemplate.ReturnCallback()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> replyCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String replyText,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    String routingKey)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"回发的消息："</span>);</span><br><span class="line">            System.out.println(<span class="string">"replyCode: "</span>+replyCode);</span><br><span class="line">            System.out.println(<span class="string">"replyText: "</span>+replyText);</span><br><span class="line">            System.out.println(<span class="string">"exchange: "</span>+exchange);</span><br><span class="line">            System.out.println(<span class="string">"routingKey: "</span>+routingKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-进入备份交换机"><a href="#2-2-进入备份交换机" class="headerlink" title="2.2 进入备份交换机"></a>2.2 进入备份交换机</h3><p>消息路由到备份交换机的方式：在创建交换机的时候，从属性中指定备份交换机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String,Object&gt;(); </span><br><span class="line">arguments.put(<span class="string">"alternate-exchange"</span>,<span class="string">"ALTERNATE_EXCHANGE"</span>);<span class="comment">// 指定交换机的备份交换机</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"TEST_EXCHANGE"</span>,<span class="string">"topic"</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,arguments); <span class="comment">// 声明交换机</span></span><br></pre></td></tr></table></figure><p>注：备份交换机是对于在消息路由处失败，还没有进入消息队列的消息，而死信是已经入队，但过期或投递失败的</p><h2 id="3-Queue存储消息"><a href="#3-Queue存储消息" class="headerlink" title="3.Queue存储消息"></a>3.Queue存储消息</h2><p>第三个环节是消息在队列存储，如果没有消费者的话，队列一直存在在数据库中。</p><h3 id="3-1-持久化到硬盘"><a href="#3-1-持久化到硬盘" class="headerlink" title="3.1 持久化到硬盘"></a>3.1 持久化到硬盘</h3><p>如果RabbitMQ的服务或者硬件发生故障，比如系统宕机、重启、关闭等等，可能会导致内存中的消息丢失，所以要把消息本身和元数据（队列、交换机、绑定）都保存到磁盘。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"myQueue"</span>) <span class="comment">// 队列持久化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//queueName,durable,exclusive,autoDelete,Properties </span></span><br><span class="line">    returnnewQueue(<span class="string">"MY_TEST_QUEUE"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,newHashMap&lt;&gt;());  <span class="comment">// 配置持久化为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"myExchange"</span>) <span class="comment">// 交换机持久化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">exchange</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="comment">//exchangeName,durable,exclusive,autoDelete,Properties </span></span><br><span class="line">    <span class="keyword">return</span> newDirectExchange(<span class="string">"JMY_TEST_EXCHANGE"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,newHashMap&lt;&gt;()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另外，在Producer发送消息时还要设置消息为持久化的（注：Message是Spring AMQP封装的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties(); <span class="comment">// 创建消息配置</span></span><br><span class="line">messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT); <span class="comment">// 配置消息持久化</span></span><br><span class="line">Message message = <span class="keyword">new</span> Message(<span class="string">"持久化消息"</span>.getBytes(), messageProperties); <span class="comment">// 创建Message时传入配置</span></span><br><span class="line"></span><br><span class="line">rabbitTemplate.send(<span class="string">"myQueue"</span>, <span class="string">"my"</span>, message); <span class="comment">// 发送消息</span></span><br></pre></td></tr></table></figure><h3 id="3-2-集群模式"><a href="#3-2-集群模式" class="headerlink" title="3.2 集群模式"></a>3.2 集群模式</h3><p>如果只有一个RabbitMQ的节点，即使交换机、队列、消息做了持久化，如果服务崩溃或者硬件发生故障，RabbitMQ的服务一样是不可用的，所以为了提高MQ服务的可用性，保障消息的传输，我们需要有多个RabbitMQ的节点</p><h2 id="4-Queue–-gt-Consumer"><a href="#4-Queue–-gt-Consumer" class="headerlink" title="4.Queue–&gt;Consumer"></a>4.Queue–&gt;Consumer</h2><p>如果消费者收到消息后没来得及处理就发生异常，或者处理过程中发生异常，会导致④失败。服务端应该以某种方式得知消费者对消息的接收情况，并决定是否重新投递这条消息给其他消费者。</p><p>RabbitMQ提供了消费者的消息确认机制（message acknowledgement），消费者可以自动或者手动地发送ACK给服务端没有收到ACK的消息，消费者断开连接后，RabbitMQ会把这条消息发送给其他消费者。如果没有其他消费者，消费者重启后会重新消费这条消息，重复执行业务逻辑。</p><h3 id="4-1-自动ACK"><a href="#4-1-自动ACK" class="headerlink" title="4.1 自动ACK"></a>4.1 自动ACK</h3><p>消费者默认采用的是自动ack（autoAck=true），所以我们可以不断的一条一条接收消息。</p><p>而自动ack的问题在于消息丢失问题，当消息到达Consumer就会给broker返回ack，若Consumer在处理中就宕机，那么当前消息就丢失了</p><p>有没有一种方式，等Consumer处理完消息后，在当前消息的ack发给服务端？手动ACK</p><h3 id="4-2-手动ACK"><a href="#4-2-手动ACK" class="headerlink" title="4.2 手动ACK"></a>4.2 手动ACK</h3><p>RabbitMQ会等待消费者显式地回复确认信号后才从队列中移去消息，而这种方式的问题在于，若服务器未收到消费者的ack时会一直阻塞，最终可能引起消息大量堆积。</p><p>若是采用原生API，消费者在订阅队列时可以指定autoAck=false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AckConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"TEST_ACK_QUEUE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setUri(ResourceUtil.getKey(<span class="string">"rabbitmq.uri"</span>));</span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        Connection conn = factory.newConnection();</span><br><span class="line">        <span class="comment">// 创建消息通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明队列（默认交换机AMQP default，Direct）</span></span><br><span class="line">        <span class="comment">// String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(<span class="string">" Waiting for message...."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建消费者，并接收消息</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String msg = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Received message : '"</span> + msg + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (msg.contains(<span class="string">"拒收"</span>))&#123;</span><br><span class="line">                    <span class="comment">// 拒绝消息</span></span><br><span class="line">                    <span class="comment">// requeue：是否重新入队列，true：是；false：直接丢弃，相当于告诉队列可以直接删除掉</span></span><br><span class="line">                    <span class="comment">// TODO 如果只有这一个消费者，requeue 为true 的时候会造成消息重复消费</span></span><br><span class="line">                    channel.basicReject(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.contains(<span class="string">"异常"</span>))&#123;</span><br><span class="line">                    <span class="comment">// 批量拒绝（拒绝deliveryTag之前的消息）</span></span><br><span class="line">                    <span class="comment">// requeue：是否重新入队列</span></span><br><span class="line">                    <span class="comment">// TODO 如果只有这一个消费者，requeue 为true 的时候会造成消息重复消费</span></span><br><span class="line">                    channel.basicNack(envelope.getDeliveryTag(), <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 手工应答</span></span><br><span class="line">                    <span class="comment">// 如果不应答，队列中的消息会一直存在，重新连接的时候会重复消费</span></span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始获取消息，注意这里开启了手工应答</span></span><br><span class="line">        <span class="comment">// String queue, boolean autoAck, Consumer callback</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring AMQP中 MessageListener 相当于消费者，可以在<code>AcknowledgeMode</code>枚举类中看到，关于ack的配置具体有三种选择： </p><ul><li>NONE：自动ACK（默认）</li><li>MANUAL： 手动ACK</li><li>AUTO：如果方法未抛出异常，则发送ack。<ul><li>当抛出 AmqpRejectAndDontRequeueException 异常的时候，则消息会被拒绝，且不重新入队。</li><li>当抛出 ImmediateAcknowledgeAmqpException 异常，则消费者会发送ACK。</li><li>其他的异常，则消息会被拒绝，且 requeue = true会重新入队。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">// 构建MessageListenerContainer的Bean时配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">container</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer(connectionFactory);</span><br><span class="line">    </span><br><span class="line">    container.setQueues(getSecondQueue(),getThirdQueue()); <span class="comment">// 监听的队列 </span></span><br><span class="line">    container.setConcurrentConsumers(<span class="number">1</span>); <span class="comment">// 最小消费者数 </span></span><br><span class="line">    container.setMaxConcurrentConsumers(<span class="number">5</span>); <span class="comment">// 最大的消费者数量 </span></span><br><span class="line">    container.setDefaultRequeueRejected(<span class="keyword">false</span>); <span class="comment">// 是否重回队列 </span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.AUTO); <span class="comment">// 签收模式！！！</span></span><br><span class="line">    container.setExposeListenerChannel(<span class="keyword">true</span>); </span><br><span class="line">    container.setConsumerTagStrategy(<span class="keyword">new</span> ConsumerTagStrategy() &#123; <span class="comment">// 消费端的标签策略</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">createConsumerTag</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若在SpringBoot的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.listener.direct.acknowledge-mode=manual  # 默认为NONE,自动ack</span><br><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span><br></pre></td></tr></table></figure><p>具体的调用代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"SECOND_QUEUE"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondConsumer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitHandler</span> </span><br><span class="line">    <span class="comment">// 当要手动确认时，参数中要有Channel和Message (注：Channel是rabbitmq.client.Channel不是amqp的)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String msg,Channel channel,Message message)</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"Second Queue received msg:"</span> + msg); </span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>); <span class="comment">// 手动ack</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-拒绝Reject"><a href="#4-2-拒绝Reject" class="headerlink" title="4.2 拒绝Reject"></a>4.2 拒绝Reject</h3><p>如果消息无法处理或者消费失败，也有两种拒绝的方式，</p><ul><li><code>void basicReject(long deliveryTag, boolean requeue)</code>单条拒绝</li><li><code>void basicNack(long deliveryTag, boolean multiple, boolean requeue)</code>批量拒绝</li></ul><p>如果requeue参数设置为true，可以把这条消息重新存入队列，以便发给下一个消费者（当然，只有一个消费者的时候，这种方式可能会出现无限循环重复消费的情况。可以投递到新的队列中，或者只打印异常日志）。如果requeue为false，当消息投递失败就会丢弃。</p><p>但无论消费者是发送ACK还是NACK，甚至是消费者出现异常，生产者也是完全不知情的。所以，生产者最终确定消费者有没有消费成功的方式：</p><ul><li>消费者收到消息，处理完毕后，调用生产者的API</li><li>消费者收到消息，处理完毕后，发送一条响应消息给生产者</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;RabbitMQ的可靠性投递，也就是在使用RabbitMQ实现异步通信的时候，消息丢了怎么办，消息重复消费怎么办？在RabbitMQ里面提供了很多保证消息可靠投递的机制，这个也是RabbitMQ的一个特性。&lt;/p&gt;
&lt;p&gt;在说可靠性投递的时候，必须要明确一个问题，因为效率与可靠性是无法兼得的，如果要保证每一个环节都成功，势必会对消息的收发效率造成影响。所以如果是一些业务实时一致性要求不是特别高的场合，可以牺牲一些可靠性来换取效率。比如发送通知或者记录日志的这种场景，如果用户没有收到通知，不会造成业务影响，只要再次发送就可以了。&lt;/p&gt;
&lt;p&gt;下图是RabbitMQ的工作模型，其中标出的是需要保证消息可靠性的地方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020111714475088.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;消息从生产者发送到Broker&lt;/p&gt;
&lt;p&gt;生产者把消息发到Broker之后，怎么知道自己的消息有没有被Broker成功接收？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息从Exchange路由到Queue&lt;/p&gt;
&lt;p&gt;Exchange是一个绑定列表，如果消息没有办法路由到正确的队列，会发生什么事情？应该怎么处理？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息在Queue中存储&lt;/p&gt;
&lt;p&gt;队列是一个独立运行的服务，有自己的数据库（Mnesia），它是真正用来存储消息的。如果还没有消费者来消费，那么消息要一直存储在队列里面。如果队列出了问题，消息肯定会丢失。怎么保证消息在队列稳定地存储呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消费者订阅Queue并消费消息&lt;/p&gt;
&lt;p&gt;队列的特性是什么？FIFO。队列里面的消息是一条一条的投递的，也就是说，只有上一条消息被消费者接收以后，才能把这一条消息从数据库删掉，继续投递下一条消息。那么问题来了，Broker怎么知道消费者已经接收了消息呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面，我们就从这四个方面来看，RabbitMQ是如何保证消息可靠性的。&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【RabbitMQ】高级使用：消息过期设置、死信队列、延迟队列、流控</title>
    <link href="https://yzhblog.work/posts/499c353c.html"/>
    <id>https://yzhblog.work/posts/499c353c.html</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-11-25T17:05:45.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-消息过期时间（TTL）"><a href="#1-消息过期时间（TTL）" class="headerlink" title="1.消息过期时间（TTL）"></a>1.消息过期时间（TTL）</h2><p>如果我们想设置消息在指定时间内没被消费就过期，有如下种设置方式：</p><h3 id="1-1-Queue-TTL"><a href="#1-1-Queue-TTL" class="headerlink" title="1.1 Queue TTL"></a>1.1 Queue TTL</h3><p>所有队列中的消息超过时间未被消费时都会过期，通过队列属性设置消息过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用SpringAMQP声明队列</span></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"ttlQueue"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123; </span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;(); </span><br><span class="line">    map.put(<span class="string">"x-message-ttl"</span>,<span class="number">11000</span>);<span class="comment">// 队列中的消息未被消费 11 秒后过期 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"GP_TTL_QUEUE"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,map); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201117100652264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><a id="more"></a><h3 id="1-2-Message-TTL"><a href="#1-2-Message-TTL" class="headerlink" title="1.2 Message TTL"></a>1.2 Message TTL</h3><p>设置单条消息的过期时间，在发送消息的时候指定消息属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringAMQP封装的Message</span></span><br><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">messageProperties.setExpiration(<span class="string">"4000"</span>); <span class="comment">// 消息的过期属性，单位ms</span></span><br><span class="line">messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">Message message = <span class="keyword">new</span> Message(<span class="string">"这条消息4秒后过期"</span>.getBytes(), messageProperties);</span><br><span class="line">rabbitTemplate.send(<span class="string">"GP_TTL_EXCHANGE"</span>, <span class="string">"gupao.ttl"</span>, message);</span><br></pre></td></tr></table></figure><p>如果同时指定了Message TTL和Queue TTL，则小的那个时间生效</p><h2 id="2-死信队列"><a href="#2-死信队列" class="headerlink" title="2.死信队列"></a>2.死信队列</h2><p>消息在某些情况下会变成死信（Dead Letter），比如：</p><ol><li>消息被消费者拒绝并且未设置重回队列：(NACK|| Reject)&amp;&amp;requeue== false</li><li>消息过期</li><li>队列达到最大长度，超过了Maxlength（消息数）或者 Maxlengthbytes（字节数），最先入队的消息会被发送到DLX。</li></ol><p>照理说死信应该是被抛弃的，但是如果定义了死信交换机，当消息成为死信就会进入死信队列</p><ul><li>DLX：死信交换机（Dead Letter Exchange），队列在创建的时候可以指定一个，实际上也是普通的交换机</li><li>DLQ：死信队列（DeadLetterQueue），被死信交换机绑定的队列，实际也是普通队列（例如替补球员也是普通球员）</li></ul><p><img src="https://img-blog.csdnimg.cn/2020111710075436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="2-1-死信队列使用"><a href="#2-1-死信队列使用" class="headerlink" title="2.1 死信队列使用"></a>2.1 死信队列使用</h3><p>1). 原交换机（GP_ORI_USE_EXCHANGE）、原队列（GP_ORI_USE_QUEUE） ，相互绑定。</p><ul><li>设置队列中的消息10秒钟过期，因为没有消费者，会变成死信。</li><li>指定原队列的死信交换机（GP_DEAD_LETTER_EXCHANGE）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Spring AMQP进行声明</span></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"oriUseExchange"</span>) <span class="comment">// 原交换机</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"GP_ORI_USE_EXCHANGE"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"oriUseQueue"</span>) <span class="comment">// 原队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="comment">// 10秒钟后成为死信</span></span><br><span class="line">    map.put(<span class="string">"x-message-ttl"</span>, <span class="number">10000</span>); </span><br><span class="line">    <span class="comment">// 死信交换机，当前队列中的消息变成死信后进入死信交换机</span></span><br><span class="line">    map.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"GP_DEAD_LETTER_EXCHANGE"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"GP_ORI_USE_QUEUE"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">// 绑定原队列到原交换机</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(@Qualifier(<span class="string">"oriUseQueue"</span>)</span> Queue queue,@<span class="title">Qualifier</span><span class="params">(<span class="string">"oriUseExchange"</span>)</span> </span></span><br><span class="line"><span class="function">                       DirectExchange exchange) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">"gupao.ori.use"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2). 声明死信交换机 （ GP_DEAD_LETTER_EXCHANGE ） 、 死信队列（GP_DEAD_LETTER_QUEUE），相互绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"deatLetterExchange"</span>) <span class="comment">// 队列的死信交换机</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TopicExchange <span class="title">deadLetterExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"GP_DEAD_LETTER_EXCHANGE"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(<span class="string">"deatLetterQueue"</span>) <span class="comment">// 死信队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">deadLetterQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"GP_DEAD_LETTER_QUEUE"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span> <span class="comment">// 绑定死信队列到死信交换机</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">bindingDead</span><span class="params">(@Qualifier(<span class="string">"deatLetterQueue"</span>)</span> Queue </span></span><br><span class="line"><span class="function">queue,@<span class="title">Qualifier</span><span class="params">(<span class="string">"deatLetterExchange"</span>)</span> TopicExchange exchange) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">"#"</span>); <span class="comment">// 无条件路由</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3). 最终消费者监听死信队列<br>4). 生产者发送消息</p><p><img src="https://img-blog.csdnimg.cn/20201117101835537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="3-延迟队列"><a href="#3-延迟队列" class="headerlink" title="3.延迟队列"></a>3.延迟队列</h2><p>我们在实际业务中有一些需要延时发送消息的场景，例如：</p><ol><li>家里有一台智能热水器，需要在30分钟后启动</li><li>未付款的订单，15分钟后关闭</li></ol><p>RabbitMQ本身不支持延迟队列，总的来说有三种实现方案：</p><ol><li>先存储到数据库，用定时任务扫描</li><li>利用RabbitMQ的死信队列（Dead Letter Queue）实现</li><li>利用rabbitmq-delayed-message-exchange插件</li></ol><h3 id="3-1-TTL-DLX"><a href="#3-1-TTL-DLX" class="headerlink" title="3.1 TTL+DLX"></a>3.1 TTL+DLX</h3><p>基于消息TTL，我们来看一下如何利用死信队列（DLQ）实现延迟队列：</p><ol><li>创建一个交换机</li><li>创建一个队列，与上述交换机绑定，并且通过属性指定队列的死信交换机。</li><li>创建一个死信交换机</li><li>创建一个死信队列</li><li>将死信交换机绑定到死信队列</li><li>消费者监听死信队列</li></ol><blockquote><p>消息的流转流程：生产者 –&gt; 原交换机 –&gt; 原队列（超过TTL之后）–&gt; 死信交换机 –&gt; 死信队列 –&gt; 最终消费者</p></blockquote><p>使用死信队列实现延时消息的缺点：</p><ul><li>如果统一用队列来设置消息的 TTL，当梯度非常多的情况下，比如 1 分钟，2分钟，5分钟，10分钟，20分钟，30分钟……需要创建很多交换机和队列来路由消息。</li><li>如果单独设置消息的TTL，则可能会造成队列中的消息阻塞——前一条消息没有出队（没有被消费），后面的消息无法投递（比如第一条消息过期TTL是30min，第二条消息TTL是10min。10分钟后，即使第二条消息应该投递了，但是由于第一条消息还未出队，所以无法投递）。</li><li>可能存在一定的时间误差</li></ul><h3 id="3-2-延迟队列插件"><a href="#3-2-延迟队列插件" class="headerlink" title="3.2 延迟队列插件"></a>3.2 延迟队列插件</h3><p>在 RabbitMQ 3.5.7 及 以后的版 本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延时队列功能。同时插件依赖Erlang/OPT 18.0及以上。</p><blockquote><p>插件源码地址：<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange</a><br>插件下载地址：<a href="https://bintray.com/rabbitmq/community-plugins/rabbitmq_delayed_message_exchange" target="_blank" rel="noopener">https://bintray.com/rabbitmq/community-plugins/rabbitmq_delayed_message_exchange</a></p></blockquote><p>1). 进入插件目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis rabbitmq </span><br><span class="line"><span class="built_in">cd</span>/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.12/plugins</span><br></pre></td></tr></table></figure><p>2). 下载插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://bintray.com/rabbitmq/community-plugins/download_file?</span><br><span class="line">file_path=rabbitmq_delayed_message_exchange-0.0.1.ez</span><br></pre></td></tr></table></figure><p>如果下载的文件名带问号则需要改名，如图</p><p><img src="https://img-blog.csdnimg.cn/20201117102301333.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv download_file?file_path=rabbitmq_delayed_message_exchange-0.0.1.ez </span><br><span class="line">rabbitmq_delayed_message_exchange-0.0.1.ez</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201117102326303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>3). 启用插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span>  rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>4). 停用插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">disable</span> rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>5). 使用插件</p><p>   通过声明一个x-delayed-message类型的Exchange来使用delayed-messaging特性。 x-delayed-message是插件提供的类型，并不是rabbitmq本身的（区别于direct、topic、fanout、headers）。</p><p>  <img src="https://img-blog.csdnimg.cn/20201117102416748.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"delayExchange"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; argss = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        argss.put(<span class="string">"x-delayed-type"</span>, <span class="string">"direct"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"GP_DELAY_EXCHANGE"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, argss);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生产者：消息属性中指定x-delay参数（SpringAMQP)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties messageProperties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line"><span class="comment">// 延迟的间隔时间，目标时刻减去当前时刻</span></span><br><span class="line">messageProperties.setHeader(<span class="string">"x-delay"</span>, delayTime.getTime() - now.getTime());</span><br><span class="line">Message message = <span class="keyword">new</span> Message(msg.getBytes(), messageProperties);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能在本地测试，必须发送消息到安装了插件的服务端</span></span><br><span class="line">rabbitTemplate.send(<span class="string">"GP_DELAY_EXCHANGE"</span>, <span class="string">"#"</span>, message);</span><br></pre></td></tr></table></figure><h2 id="4-服务端流控"><a href="#4-服务端流控" class="headerlink" title="4.服务端流控"></a>4.服务端流控</h2><p>当RabbitMQ生产MQ消息的速度远大于消费消息的速度时，会产生大量的消息堆积，占用系统资源，导致机器的性能下降。我们想要控制服务端接收的消息的数量，应该怎么做呢？</p><h3 id="4-1-长度控制"><a href="#4-1-长度控制" class="headerlink" title="4.1 长度控制"></a>4.1 长度控制</h3><p>队列有两个控制长度的属性：</p><ul><li>x-max-length：队列中最大存储最大消息数，超过这个数量，队头的消息会被丢弃。</li><li>x-max-length-bytes：队列中存储的最大消息容量（单位bytes），超过这个容量，队头的消息会被丢弃。</li></ul><p><img src="https://img-blog.csdnimg.cn/20201117102524927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>需要注意的是，设置队列长度只在消息堆积的情况下有意义，而且会删除先入队的消息，不能真正地实现服务端限流。</p><h3 id="4-2-内存控制"><a href="#4-2-内存控制" class="headerlink" title="4.2 内存控制"></a>4.2 内存控制</h3><p>RabbitMQ 会在启动时检测机器的物理内存数值。默认当 MQ 占用 40% 以上内存时，MQ 会主动抛出一个内存警告并阻塞所有连接（Connections）。可以通过修改rabbitmq.config 文件来调整内存阈值，默认值是 0.4，如下所示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;rabbit,[&#123;vm_memory_high_watermark,0.4&#125;]&#125;].</span><br></pre></td></tr></table></figure><p>也可以用命令动态设置，如果设置成0，则所有的消息都不能发布</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_vm_memory_high_watermark 0.3</span><br></pre></td></tr></table></figure><h3 id="4-3-磁盘控制"><a href="#4-3-磁盘控制" class="headerlink" title="4.3 磁盘控制"></a>4.3 磁盘控制</h3><p>另一种方式是通过磁盘来控制消息的发布。当磁盘空间低于指定的值时（默认50MB），触发流控措施。</p><p>例如：指定为磁盘的30%或者2GB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disk_free_limit.relative=3.0 </span><br><span class="line">disk_free_limit.absolute=2GB</span><br></pre></td></tr></table></figure><p>更多相关配置内容可以参考 <a href="https://www.rabbitmq.com/configure.html" target="_blank" rel="noopener">官网</a>…</p><h2 id="5-消费端流控"><a href="#5-消费端流控" class="headerlink" title="5.消费端流控"></a>5.消费端流控</h2><p>默认情况下，如果不进行配置，RabbitMQ会尽可能快速地把队列中的消息发送到消费者。因为消费者会在本地缓存消息，如果消息数量过多，可能会导致OOM或者影响其他进程的正常运行。</p><p>在消费者处理消息的能力有限，例如消费者数量太少，或者单条消息的处理时间过长的情况下，如果我们希望在一定数量的消息消费完之前，不再推送消息过来，就要用到消费端的流量限制措施。</p><p>可以基于Consumer或者channel设置prefetch count的值，含义为Consumer端的最大的unackedmessages数目。当超过这个数值的消息未被确认，RabbitMQ会停止投递新的消息给该消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.basicQos(<span class="number">2</span>);<span class="comment">// 如果超过 2 条消息没有发送 ACK，当前消费者不再接受队列消息 </span></span><br><span class="line">channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br></pre></td></tr></table></figure><p>Spring Boot配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.rabbitmq.listener.simple.prefetch=2</span></span><br></pre></td></tr></table></figure><p>关于Consumer Prefetch 官网也给出了相应<a href="https://www.rabbitmq.com/consumer-prefetch.html" target="_blank" rel="noopener">解释</a>….</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-消息过期时间（TTL）&quot;&gt;&lt;a href=&quot;#1-消息过期时间（TTL）&quot; class=&quot;headerlink&quot; title=&quot;1.消息过期时间（TTL）&quot;&gt;&lt;/a&gt;1.消息过期时间（TTL）&lt;/h2&gt;&lt;p&gt;如果我们想设置消息在指定时间内没被消费就过期，有如下种设置方式：&lt;/p&gt;
&lt;h3 id=&quot;1-1-Queue-TTL&quot;&gt;&lt;a href=&quot;#1-1-Queue-TTL&quot; class=&quot;headerlink&quot; title=&quot;1.1 Queue TTL&quot;&gt;&lt;/a&gt;1.1 Queue TTL&lt;/h3&gt;&lt;p&gt;所有队列中的消息超过时间未被消费时都会过期，通过队列属性设置消息过期时间&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用SpringAMQP声明队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Bean&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ttlQueue&quot;&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Queue &lt;span class=&quot;title&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Map&amp;lt;String,Object&amp;gt; map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;String,Object&amp;gt;(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map.put(&lt;span class=&quot;string&quot;&gt;&quot;x-message-ttl&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11000&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 队列中的消息未被消费 11 秒后过期 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Queue(&lt;span class=&quot;string&quot;&gt;&quot;GP_TTL_QUEUE&quot;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;,map); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201117100652264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="消息队列" scheme="https://yzhblog.work/categories/消息队列/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】集群模式（二）：哨兵模式原理分析及代码示例</title>
    <link href="https://yzhblog.work/posts/f9f73578.html"/>
    <id>https://yzhblog.work/posts/f9f73578.html</id>
    <published>2020-08-12T16:00:00.000Z</published>
    <updated>2020-11-25T15:45:49.518Z</updated>
    
    <content type="html"><![CDATA[<p>哨兵模式是基于主从模式做的一定变化，它能够为Redis提供了高可用性。在实际生产中，服务器难免不会遇到一些突发状况：服务器宕机，停电，硬件损坏等。这些情况一旦发生，其后果往往是不可估量的。而哨兵模式在一定程度上能够帮我们规避掉这些意外导致的灾难性后果。</p><a id="more"></a><h2 id="1-哨兵模式原理分析"><a href="#1-哨兵模式原理分析" class="headerlink" title="1.哨兵模式原理分析"></a>1.哨兵模式原理分析</h2><p>其实，哨兵模式的核心还是主从复制。而哨兵（sentinel）是一个独立的进程， 可以实现对Redis实例的监控、通知、自动故障转移。借助哨兵来监控master节点的状态，如果master节点异常，则会做主从切换，将某一台slave作为master。</p><p><img src="https://img-blog.csdnimg.cn/2020110700244738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"></p><p>哨兵（sentinel）是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。 </p><ul><li>哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点。</li><li>当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息) 。</li></ul><p><strong>问题一</strong>：哨兵是如何知道某个节点不可用的？</p><p>每个哨兵节点每秒通过ping去进行心跳监测（包括所有redis实例和sentinel同伴），并根据回复判断节点是否在线。</p><p>如果某个sentinel线程发现主库没有在给定时间（ down-after-milliseconds）内响应这个PING，则这个sentinel线程认为主库是不可用的，这种情况叫 <strong>主观失效（SDOWN）</strong>。这种情况一般不会引起马上的故障自动转移。</p><p>但是当多个sentinel线程确实发现主库是不可用并超过 sentinel.conf 里面的配置项 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster &#123;#ip&#125; &#123;#port&#125; &#123;#number&#125;</span><br></pre></td></tr></table></figure><p>中的#number时候（这里实际上采用了流言协议），其余sentinel线程会通过RAFT算法推举领导的sentinel线程负责主库的客观下线并同时负责故障自动转移，这种情况叫 <strong>客观失效（ODOWN）</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20201107004553350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNTkyNw==,size_16,color_FFFFFF,t_70#pic_center" width="60%"></p><blockquote><p>优点：</p><ul><li>监控：它会监听主服务器和从服务器之间是否在正常工作。</li><li>通知：它能够通过API告诉系统管理员或者程序，集群中某个实例出了问题。</li><li>故障转移：它在主节点出了问题的情况下，会在所有的从节点中竞选出一个节点，并将其作为新的主节点。</li><li>提供主服务器地址：它还能够向使用者提供当前主节点的地址。这在故障转移后，使用者不用做任何修改就可以知道当前主节点地址。</li></ul><p>缺点：</p><ul><li>哨兵的<strong>配置略微复杂</strong>，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况</li><li>哨兵模式<strong>只有一个主节点对外提供服务</strong>，没法支持很高的<strong>并发</strong></li><li><strong>单个主节点内存也不宜设置得过大</strong>，否则会导致持久化文件过大，影响数据恢复或主从同步的效率</li></ul></blockquote><h2 id="2-哨兵模式搭建"><a href="#2-哨兵模式搭建" class="headerlink" title="2.哨兵模式搭建"></a>2.哨兵模式搭建</h2><h3 id="2-1-redis哨兵搭建步骤"><a href="#2-1-redis哨兵搭建步骤" class="headerlink" title="2.1 redis哨兵搭建步骤"></a>2.1 redis哨兵搭建步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、复制一份sentinel.conf文件 </span><br><span class="line">cp sentinel.conf sentinel‐26379</span><br><span class="line"> </span><br><span class="line">2、将相关配置修改为如下值： </span><br><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;/var/run/redis‐sentinel‐26379.pid&quot; </span><br><span class="line">logfile &quot;26379.log&quot; </span><br><span class="line">dir &quot;/usr/local/redis‐5.0.3/data&quot; </span><br><span class="line"># sentinel monitor &lt;master‐name&gt; &lt;ip&gt; &lt;redis‐port&gt; &lt;quorum&gt; </span><br><span class="line"># quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/2 + 1)，master才算真正失效）</span><br><span class="line">sentinel monitor mymaster 192.168.0.60 6379 2</span><br><span class="line"></span><br><span class="line">3、启动sentinel哨兵实例 </span><br><span class="line">src/redis‐sentinel sentinel‐26379.conf</span><br><span class="line"></span><br><span class="line">4、查看sentinel的info信息 </span><br><span class="line">src/redis‐cli ‐p 26379 </span><br><span class="line">127.0.0.1:26379&gt;info</span><br><span class="line">可以看到Sentinel的info里已经识别出了redis的主从</span><br><span class="line"></span><br><span class="line">5、可以自己再配置两个sentinel，端口26380和26381，注意上述配置文件里的对应数字都要修改</span><br></pre></td></tr></table></figure><h3 id="2-2-哨兵的Jedis连接代码"><a href="#2-2-哨兵的Jedis连接代码" class="headerlink" title="2.2 哨兵的Jedis连接代码"></a>2.2 哨兵的Jedis连接代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisSentinelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">20</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">5</span>);</span><br><span class="line">        </span><br><span class="line">        String masterName = <span class="string">"mymaster"</span>;</span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"39.105.132.120"</span>, <span class="number">26379</span>).toString());</span><br><span class="line">        sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"39.105.132.120"</span>, <span class="number">26380</span>).toString());</span><br><span class="line">        sentinels.add(<span class="keyword">new</span> HostAndPort(<span class="string">"39.105.132.120"</span>, <span class="number">26381</span>).toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JedisSentinelPool其实本质与JedisPool类似，都是与redis主节点建立的连接池</span></span><br><span class="line">        <span class="comment">// JedisSentinelPool并不是说与sentinel建立的连接池，而是通过sentinel发现redis主节点，并与其建立连接</span></span><br><span class="line">        JedisSentinelPool jedisSentinelPool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels, jedisPoolConfig, <span class="number">3000</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        Jedis jedis = jedisSentinelPool.getResource();</span><br><span class="line">        System.out.println(jedis.set(<span class="string">"sentinel"</span>, <span class="string">"lisi"</span>));</span><br><span class="line">        System.out.println(jedis.get(<span class="string">"sentinel"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-基于SpringBoot"><a href="#2-3-基于SpringBoot" class="headerlink" title="2.3 基于SpringBoot"></a>2.3 基于SpringBoot</h3><p>引入相关依赖： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐data‐redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons‐pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>springboot项目核心配置： </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">    lettuce:</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line">        <span class="comment"># 连接池最大连接数(使用负值表示没有限制) 默认为8</span></span><br><span class="line"><span class="attr">        max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接 默认为8</span></span><br><span class="line"><span class="attr">        max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池最大阻塞等待时间(使用负值表示没有限制) 默认为-1</span></span><br><span class="line"><span class="attr">        max-wait:</span> <span class="bullet">-1</span><span class="string">ms</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接 默认为 0</span></span><br><span class="line"><span class="attr">        min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#哨兵模式 </span></span><br><span class="line"><span class="attr">    sentinel:</span></span><br><span class="line">      <span class="comment"># 主节点的别名</span></span><br><span class="line"><span class="attr">      master:</span> <span class="string">mymaster</span></span><br><span class="line">      <span class="comment"># sentinel服务的ip和端口</span></span><br><span class="line"><span class="attr">      nodes:</span> <span class="number">39.105</span><span class="number">.136</span><span class="number">.120</span><span class="string">:26379,39.105.136.120:26380,39.105.136.120:26381</span></span><br></pre></td></tr></table></figure><p>访问代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用SpringBoot封装的RestTemplate对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">      * 测试节点挂了哨兵重新选举新的master节点，客户端是否能动态感知到 </span></span><br><span class="line"><span class="comment">      * 新的master选举出来后，哨兵会把消息发布出去，客户端实际上是实现了一个消息监听机制， </span></span><br><span class="line"><span class="comment">      * 当哨兵把新master的消息发布出去，客户端会立马感知到新master的信息，从而动态切换访问的maste rip </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSentinel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"test"</span>+i, i+<span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"设置key:"</span> + <span class="string">"test"</span> + i);</span><br><span class="line">            i++;</span><br><span class="line">           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        String value = redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/set"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;哨兵模式是基于主从模式做的一定变化，它能够为Redis提供了高可用性。在实际生产中，服务器难免不会遇到一些突发状况：服务器宕机，停电，硬件损坏等。这些情况一旦发生，其后果往往是不可估量的。而哨兵模式在一定程度上能够帮我们规避掉这些意外导致的灾难性后果。&lt;/p&gt;</summary>
    
    
    
    <category term="数据存储" scheme="https://yzhblog.work/categories/数据存储/"/>
    
    
    <category term="学习ing" scheme="https://yzhblog.work/tags/学习ing/"/>
    
    <category term="开发组件" scheme="https://yzhblog.work/tags/开发组件/"/>
    
  </entry>
  
</feed>
